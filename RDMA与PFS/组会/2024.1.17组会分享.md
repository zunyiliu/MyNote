# Memory Region
RDMA从内存中取出数据时不会经过CPU，然而在用户空间中的数据地址都是虚拟地址，经过MMU的转换才能得到真实的物理地址。

一方面RDMA需要有一个虚拟地址到物理地址的映射表，这样才能正确转换地址。另一方面RDMA需要防止用户程序恶意指定的虚拟地址，从而访问不该访问的内存。基于这两个原因，RDMA提出了Memory Region的概念。

MR包含以下功能：
1. 注册MR时，创建一个VA to PA的映射表。
2. 注册MR时，创建两把钥匙——L_KEY（Local Key）和R_KEY（Remote Key），用于权限保护。
3. 注册MR时，pin住数据页，防止数据页被操作系统的page cache所替换，进而导致VA to PA的关系变化

# Protection Domain
由于MR和QP之间没有绑定关系，理论上本端QP和远端QP建立连接后，就可以通过猜测VA和R_KEY的方式访问任意一块远端MR，显然这是不安全的。

为解决这个问题，RDMA在本端设置PD，用于捆绑QP和MR，只有在QP访问的MR同属于一个PD时，才能正确访问。

# Queue Pair
通信的基本单位，可以类比于传统网络中的Socket，包含多个通信状态。

# Completion Queue
硬件通过CQ中的CQE/WC来告诉软件某个WQE/WR的完成情况。

根据服务类型的不同，生成CQE的时间也不同。

每个WQ都必须关联一个CQ，而每个CQ可以关联多个SQ和RQ：
- 同一个WQ中的WQE，其对应的CQE间是保序的
- 不同WQ中的WQE，其对应的CQE间是不保序的
- CQE通过指明WQE的编号关联WQE

# Verbs
Verbs是IB规范下的一组抽象定义，规定了各厂商硬件在各种Verbs下应该完成的动作。

Verbs API是具体的软件接口，传统以太网使用Socket API来编程，而RDMA采用Verbs API来编程。

Verbs API包含两个部分：
- IB_VERBS：接口以ibv_xx（用户态）或者ib_xx（内核态）作为前缀，是最基础的编程接口。对应的头文件是`#include <infiniband/verbs.h>`
- RDMA\_CM：以rdma\_为前缀，主要分为两个功能
	- CMA：在Verbs API基础上实现的，用于CM建链并交换信息的一组接口。对应的头文件是`#include <rdma/rdma_cma.h> `
	- CM VERBS：在verbs API基础上实现的，用于数据交换的一组接口。对应的头文件是`#include <rdma/rdma_verbs.h>  `

专栏中给出了一个RDMA的大致接口调用流程：还不是很懂。

# RDMA用户态与内核态交互
前面我们提到过RDMA程序可以绕开CPU直接从内存中读写数据，但这仅限于数据层面。

在控制层面，RDMA首先要通过控制路径与内核进行交互，包括注册MR、创建QP等，因为这涉及一些特定资源的使用，交给用户态的程序是不安全的。

# RoCE与Soft-RoCE
## RoCE的层次
RoCE v2是一种在以太网传输层基础上实现的一套协议，层次如下：
![[Pasted image 20240117115814.png]]

对应的一个RoCE v2报文层次如下，即RoCE数据包由以太网UDP进行传输
![[Pasted image 20240117115300.png]]

## RoCE的优势如下：
1. Infiniband协议定义了一套全新的层次架构，无法与现有以太网兼容。数据中心如果需要切换到Infiniband技术，就需要购买全套的Infiniband设备，且不能与以太网兼容。
2. RoCE由于是在以太网传输层上实现的一套协议，可以兼容以太网的网络设备，而只需要购买支持RoCE的网卡。

## Soft-RoCE
RoCE已经降低了很多成本，但对于个人开发者来说，支持RoCE的网卡仍然昂贵，因而可以采用Soft-RoCE。Soft-RoCE其实就是将RoCE网卡中的硬件工作又重新搬回到软件中实现，因而效率会有所降低。

Soft-RoCE有以下优势：
- 降低RoCE部署成本：Soft-RoCE可以使不具备RoCE能力的硬件和支持RoCE的硬件间进行基于IB语义的交流，这样可以**免于替换网络中的一些非关键节点的旧型号网卡**。
- 便于开发和测试RDMA程序：有了Soft-RoCE，我们基于Verbs API编写的程序，就可以不依赖于硬件执行起来，也可以很方便的跑在虚拟机里。

## 虚拟机实验
简单跑了下perftest测试，但其实没太看明白。

# Send & Recv
## rdma函数
### RdmaGetRdmaDeviceInfoByNames
该函数通过传入一组设备名，返回这些设备的`RdmaDeviceInfo`，接口如下：
```cpp
vector<RdmaDeviceInfo> RdmaGetRdmaDeviceInfoByNames(const vector<string> &names,
                                                    int &link_type)
```

函数流程如下：
1. 调用`struct ibv_device **ibv_get_device_list(int *num_devices)`，获取服务器上所有设备的`ibv_device`
2. 通过对比设备名的方式找到对应设备的`ibv_device`，并调用`ibv_open_device()`获取该设备的`ibv_context`
3. 调用`ibv_query_device()`，获取设备的`ibv_device_attr`
4. 调用`ibv_query_port()`，并根据查询设备信息使用的默认端口号`kRdmaDefaultPort`，获取设备的`ibv_port_attr`
5. 调用`ibv_alloc_pd`，为该设备分配一个`pd`

### RdmaModifyQp2Rts
该函数负责将QP的状态切换到RTS，其中会经过INIT、RTR、RTS三个状态。通过调用`ibv_modify_qp()`函数，将需要修改的`ibv_qp_attr`传入，从而修改`qp`的状态和参数。

#### INIT
![[Pasted image 20240131103613.png]]
切换到INIT状态时的参数修改如上：
- qp_state：下一个qp的状态，此处是IBV_QPS_INIT
- qp_access_flags：允许对方QP的操作类型，这里直接设置为允许READ、ATOMIC、WRITE操作
- pkey_index：pkey在pkey table中的位置，关于pkey可以看这个[介绍](https://www.rdmamojo.com/2014/04/30/partition-key-p_key/)，大致类似于VLAN的功能(?)
- port_num：查询设备信息的端口号，和设备有关，见下图
![[Pasted image 20240131104324.png]]

#### RTR
![[Pasted image 20240131104510.png]]
切换到RTR状态时的参数修改如上：
- qp_state：下一个qp状态为IBV_QPS_RTR
- path_mtu：即一个报文的最大长度，此处设置为1024字节
- rq_psn：_A 24 bits value of the Packet Sequence Number of the received packets for RC and UC QPs_，好像是允许接收的报文起始序列号，和sq_psn对应。按道理应该在ExchangeQP的信息中获取，但这里直接约定双方从0开始
- dest_qp_num：对端QPN
- max_dest_rd_atomic：可同时处理的对端read、atomic操作数量，这里设置为1
- min_rnr_timer：当对端发来一个操作时，应该消耗本端RQ中的一个WR，如果没有就发送一个RNR NAK给对方。该字段值就是对应RNR NAK 定时器字段值
- ah_attr：用于描述链路信息：
	- dlid：对端的lid。lid用于Infiniband协议栈链路层中的寻址，所以对于RoCE v2而言，这个值应该是0
	- sl：service level，_不是很懂_
	- src_path_bits：_看不懂_
	- port_num：报文转发端口
	- grh：用于跨子网传输报文，_不是很懂_

#### RTS
![[Pasted image 20240131112211.png]]
切换到RTS状态时的参数修改如上：
- qp_state：下一个qp状态为IBV_QPS_RTS
- sq_psn：发送报文的起始序列号
- max_rd_atomic：可同时进行的read、atomic操作数量，这里设置为1
- timeout：超时重发时间
- retry_cnt：超时重发次数
- rnr_retry：收到RNR NAK时的重发次数，7代表重试无数次

## Server端流程
![[Pasted image 20240131113448.png]]
在Send & Recv的情况下，Server端流程图如上。

### BuildRdmaEnvironment
该函数通过传入设备名字符串，获取该设备的`RdmaDeviceInfo`、注册`MR`、建立`CQ`，其接口如下
```cpp
void BuildRdmaEnvironment(const string &dev_name)
```

函数流程如下：
1. 调用`RdmaGetRdmaDeviceInfoByNames()`函数，传输设备名，获取设备的`RdmaDeviceInfo`
2. 调用`memalign()`，分配一块地址对齐的空间，并调用`ibv_reg_mr()`注册该空间
3. 调用`CreateCq()`，创建`cq`

### ExchangeQP
Server端将`ExchangeQP`绑定为RPC操作，供对端进行调用，流程如下：
1. 调用`RdmaCreateQp`，创建一个`qp`
2. 获取本端和对端的`lid`、`QPN`、`gid_index`、`gid`
3. 调用`RdmaModifyQp2Rts`，将QP切换到RTS状态
4. 调用`RdmaPostRecv`，将MR全部作为目标地址下发到RQ中

### ibv_poll_cq
网卡收到对端的send后，消耗RQ中的一个QPE，写入其对应的地址后，向CQ中传入一个WC，表示任务完成。调用ibv_poll_cq可以取出CQ中的WC，从而获取“完成报告”。

## Client端流程
![[Pasted image 20240131114243.png]]
这里仅讲述与Server端的不同点。

### BuildRdmaEnvironment
在MR中填入了需要发送的信息，从而在下发Send WR时可以指定发送内容

### RdmaPostSend
调用RdmaPostSend时，指定MR中的区域，从而发送不同的内容。

# Write
Write的流程与Send基本相同，同样是调用`RdmaPostSend`下发一个请求，不过需要指定对端写入地址`remote_addr`和`rkey`，对端不需要消耗RQ的WR，也就无法感知写入，可以通过写入指定区域内容或通过TCP链进行同步。

# 
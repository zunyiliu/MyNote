# Send & Recv
## rdma函数
### RdmaGetRdmaDeviceInfoByNames
该函数通过传入一组设备名，返回这些设备的`RdmaDeviceInfo`，接口如下：
```cpp
vector<RdmaDeviceInfo> RdmaGetRdmaDeviceInfoByNames(const vector<string> &names,
                                                    int &link_type)
```

函数流程如下：
1. 调用`struct ibv_device **ibv_get_device_list(int *num_devices)`，获取服务器上所有设备的`ibv_device`
2. 通过对比设备名的方式找到对应设备的`ibv_device`，并调用`ibv_open_device()`获取该设备的`ibv_context`
3. 调用`ibv_query_device()`，获取设备的`ibv_device_attr`
4. 调用`ibv_query_port()`，并根据查询设备信息使用的默认端口号`kRdmaDefaultPort`，获取设备的`ibv_port_attr`
5. 调用`ibv_alloc_pd`，为该设备分配一个`pd`

### RdmaModifyQp2Rts
该函数负责将QP的状态切换到RTS，其中会经过INIT、RTR、RTS三个状态。通过调用`ibv_modify_qp()`函数，将需要修改的`ibv_qp_attr`传入，从而修改`qp`的状态和参数。

#### INIT
![[Pasted image 20240131103613.png]]
切换到INIT状态时的参数修改如上：
- qp_state：下一个qp的状态，此处是IBV_QPS_INIT
- qp_access_flags：允许对方QP的操作类型，这里直接设置为允许READ、ATOMIC、WRITE操作
- pkey_index：pkey在pkey table中的位置，关于pkey可以看这个[介绍](https://www.rdmamojo.com/2014/04/30/partition-key-p_key/)，大致类似于VLAN的功能(?)
- port_num：查询设备信息的端口号，和设备有关，见下图
![[Pasted image 20240131104324.png]]

#### RTR
![[Pasted image 20240131104510.png]]
切换到RTR状态时的参数修改如上：
- qp_state：下一个qp状态为IBV_QPS_RTR
- path_mtu：即一个报文的最大长度，此处设置为1024字节
- rq_psn：_A 24 bits value of the Packet Sequence Number of the received packets for RC and UC QPs_，好像是允许接收的报文起始序列号，和sq_psn对应。按道理应该在ExchangeQP的信息中获取，但这里直接约定双方从0开始
- dest_qp_num：对端QPN
- max_dest_rd_atomic：可同时处理的对端read、atomic操作数量，这里设置为1
- 

## Server端流程
![[Pasted image 20240131100549.png]]
在Send & Recv的情况下，Server端流程图如上。

### BuildRdmaEnvironment
该函数通过传入设备名字符串，获取该设备的`RdmaDeviceInfo`、注册`MR`、建立`CQ`，其接口如下
```cpp
void BuildRdmaEnvironment(const string &dev_name)
```

函数流程如下：
1. 调用`RdmaGetRdmaDeviceInfoByNames()`函数，传输设备名，获取设备的`RdmaDeviceInfo`
2. 调用`memalign()`，分配一块地址对齐的空间，并调用`ibv_reg_mr()`注册该空间
3. 

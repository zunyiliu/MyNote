# 概论
MR机制的设计目的：
1. 进行虚拟地址到物理地址的转换
2. 控制访问权限
3. 防止换页（Pin页）

本节我们主要讨论第一点，即硬件是如何通过MR来进行地址转换的。

# 虚拟和物理地址的转换
由于MR是一块连续的虚拟地址内存，我们可以记录其起始虚拟地址和分配的物理page地址，这样我们就可以根据目的虚拟地址找到对应的物理地址，如下图：
![[Pasted image 20240121123349.png]]

# MR Context
RDMA网卡中需要有一个表格来记录每个MR的相关信息，每个厂商对此的命名不同，我们这里称其为MR Context。

# MR的实体
- 从用户的视角看，MR是一个可以被HCA访问的虚拟地址连续的内存空间。
- 从驱动程序和硬件的视角看，MR包含了MRC、页表以及若干分散到物理内存空间中的页面。

# 注册流程（控制路径）
## 用户态
### 应用程序调用Verbs API
```c
struct ibv_mr *ibv_reg_mr(struct ibv_pd *pd, void *addr, size_t length, int access);
```
参数：
- pd：MR关联的PD指针
- addr：起始虚拟地址
- length：MR长度
- access：MR的本地和远端访问权限

用户在应用程序中调用标准Verbs API之后，rdma-core的公共代码会调用对应设备注册的回调函数，进入用户态驱动中。

### 用户态驱动陷入内核态
用户态驱动只是做一层对框架函数的调用，然后就陷入内核态进行下一步处理。

## 内核态
这一块的内容和Queue Buffer在内核态中的操作基本相同，这里只说不同点。

### 产生L_Key和R_Key
L_Key和R_Key两个秘钥，RDMA网卡用它们来校验本端和远端对本地内存的访问权限。如下图所示，它们由两部分组成：其中24bits为index部分，只有8bits才是秘钥key。
![[Pasted image 20240121123920.png]]
- index：index部分的功能和QPN是类似的，是MR的**唯一**编号，硬件通过这个index就可以找到一个MR的MRC表项，从而进一步获取其信息。
- key：这个8bit域段才是真正用于校验的部分，一般是由驱动生成一个随机值。

# 使用流程（数据路径）
## Write操作
假设在以下步骤前，双方的已经在控制路径上将需要的MR注册好，并且拿到了L_Key和R_Key。
![[Pasted image 20240121124144.png]]

### 1. 准备数据
首先，Requester侧的用户需要在本地内存中准备好要写到对端内存的数据，也就是Payload。

### 2. 下发WR
用户调用ibv_post_send()或者其他下发WR的Verbs API，来指示HCA发包。

### 3. HCA解析WQE
硬件收到Doorbell之后，通过其中的信息获取到QPN和WQE的index，然后根据QPC中记录的WQE Buffer信息，算出WQE的地址。接着就取出WQE并进行解析。

### 4. 组装并发送消息
经过了之前的步骤，HCA现在已经具备了组装报文所需的全部信息。组装好的报文如下图：
![[Pasted image 20240121124549.png]]
接下来经过物理链路的传输，报文最终到达了Responder一侧。

### 5. 接收并解析报文
Responder的HCA收到报文后，将对其内容进行解析和校验。

### 6. 将Payload写入内存
校验通过并且得到最终的PA之后，HCA就可以通过DMA将报文中的Payload写入目的内存了。

Responder可能会回复ACK给Requester，并且Requester一侧可能会产生CQE，这些流程我们不在本文中展开。

# 总结
![[Pasted image 20240121125046.png]]
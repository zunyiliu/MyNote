# 为什么QP间需要建链
QP间进行通信之前，需要知道对方的GID和QPN等信息，这些信息需要依靠建链来获得。

# 基于Socket API的QP建链
## 概述
基于Socket API进行RDMA QP间的建链，指的就是**先在两个节点间通过Socket API建立TCP/IP的连接，然后通过这条连接来交互双方的QP信息**。

Socket 建链需要网卡支持TCP/IP协议，因而运行Infiniband/RoCE v1的设备不能使用这种建链方式。iWARP协议的TCP/IP建链流程被封装到了CM API里面，因而也不能使用这种建链方式。**只有RoCE v2协议的用户才可以选择直接使用基于Socket API建链方式**。

## 通过Socket连接交换信息
Socket建链之后，需要开发者自己设计交互的逻辑和内容：
- 交互逻辑其实很简单，无非就是你发我收，我发你收；
- 用户在决定交互内容上的自由度很高，可以根据具体应用逻辑的来定。

有一些必须要交换的信息：
![[Pasted image 20240122102831.png]]

### GID
即全局ID，是Infiniband网络层（Network Layer）的地址，用于在跨子网时做路由。
- 在Infiniband协议中，它的作用跟TCP/IP协议中的网络层地址，即IP地址的作用是一样的。
- 在RoCE v2中，这实际上就是IP地址。

### QPN
QPN是一个节点本地某个QP的唯一编号，可以类比为端口号。

如下图所示，通过GID + QPN的组合，我们就能在网络中唯一确定一个QP了：
![[Pasted image 20240122103015.png]]

### Q_Key
Q_Key是只在UD模式下使用的一种Key。UD服务类型的特点就是无连接，不用建立QP间的连接（区别于本文的建链）可以发送消息给任何QP。因而可能出现这样一种情况：
- 有一个恶意的用户不停的给这个UD QP发送Send消息，如果不加以防备的话，这个UD QP就会不断消耗RQ WQE用于接收这些报文，从而导致无法处理合法的Send（类似于DoS——Denial of Service攻击）。

因而Q_Key就是解决这个问题。本端用户在创建UD之后，会通过Modify QP将指定的Q_Key写入到QPC中，然后通过建链将Q_Key传递给对方。对端接收报文后，会将其中的Q_Key与事先存储的Q_Key进行校验。
![[Pasted image 20240122103313.png]]

## 通过Socket连接做同步
Socket连接不是在交换完QP建链所需的信息之后就没用了，我们还可以利用它来做两端的同步，因为双方在程序流程上可能会有相互依赖。

比如Send/Recv操作中，如果收端的程序还没有Post Receive WR的情况下，发端就通过下发Post Send WR触发硬件发送了报文，这时就会发生RNR（Receive Not Ready）错误，即接收端还没有准备好接收报文。因而可以通过Socket连接进行同步操作。
![[Pasted image 20240122103411.png]]



- [[#C++ 中智能指针和指针的区别是什么|C++ 中智能指针和指针的区别是什么]]
- [[#简述 C++ 右值引用与转移语义|简述 C++ 右值引用与转移语义]]
- [[#new与malloc的区别|new与malloc的区别]]
- [[#C++多态|C++多态]]
- [[#简述vector的原理|简述vector的原理]]
- [[#C++ 虚函数和纯虚函数的区别|C++ 虚函数和纯虚函数的区别]]
- [[#C/C++内存存储区有哪几种类型|C/C++内存存储区有哪几种类型]]
- [[#简述 C++ 从代码到可执行二进制文件的过程|简述 C++ 从代码到可执行二进制文件的过程]]

# C++ 中智能指针和指针的区别是什么
1. 智能指针在指针的基础上添加了更多的管理功能，包括过期时自动调用析构函数来释放地址，以及转让所有权时的控制策略。
2. C++11提供了三种智能指针，分别是：unique_ptr、shared_ptr、weak_ptr。
3. unique_ptr在创建时转让旧指针所有权，并保证只能由一个智能指针拥有它
4. shared_ptr在通过引用计数，跟踪引用特定对象的智能指针数。只有在引用数减为0时才调用析构函数
5. weak_ptr指向一个 shared_ptr 管理的对象，由shared_ptr进行内存管理，其构造不会增加或减少shared_ptr的引用数

# 简述 C++ 右值引用与转移语义
右值引用是 C++11中引入的新特性 , 它实现了转移语义。它的主要目的是：
- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。

**左值与右值**
一个左值表达式表示的是对象的身份，而右值表达式表示的是对象的值，个人的理解：左值对应变量的存储位置，而右值对应变量的值本身。

因此右值引用同样也是实际内存对象的一个名字，而左值引用要求一个明确的对象

**转移语义**
右值引用是用来支持转移语义的。**转移语义**可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。

其中我们可以使用std::move把一个左值引用当作右值引用来使用，这样就可以避免拷贝

# new与malloc的区别
new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数

new可以看成两个动作：
1. 分配内存（相当于malloc)
2. 引发构造函数。

# C++多态
类之间进行继承时，对虚函数的重新定义称为多态

# 简述vector的原理
`vector` 实际上是一个动态数组，**预先指向一段连续的已分配好的内存空间**。

通俗地讲，当在 `vector` 中插入元素且 `vector` 当前的容量不足以存放时，`vector` 会重新开辟一段新的内存空间，**将原有的数据全部拷贝到新空间后并插入新数据后，再将原有的空间段进行释放**。

注意：**每次扩容容量会增加原来内存大小的2倍或1.5倍**。

# C++ 虚函数和纯虚函数的区别
在 C++ 中，虚函数（virtual function）是一个可以被子类重写的成员函数，而纯虚函数（pure virtual function）是一个在基类中声明的虚函数，但不会在基类中实现，而是要求派生类中实现的函数。

两者具体区别如下：
1. 虚函数是有实现的，而纯虚函数没有实现。虚函数在基类中有默认实现，子类可以重写它，也可以不重写，但纯虚函数必须在子类中实现。
2. 如果一个类中包含至少一个纯虚函数，那么这个类就是抽象类，不能直接实例化对象。而虚函数不会强制一个类成为抽象类。
3. 纯虚函数可以为接口提供一个规范，子类必须实现这些接口。而虚函数则允许子类通过重写来扩展或修改父类的实现。
4. 纯虚函数只能在抽象类中声明，而虚函数可以在任何类中声明

# C/C++内存存储区有哪几种类型
1.栈区（stack） --编译器自动分配释放，主要存放函数的参数值，局部变量值等；  
2.堆区（heap） --由程序员分配释放；  
3.全局区或静态区 --存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区和全局未初始化区；  
4.字符常量区 --常量字符串放与此，程序结束时由系统释放；  
5.程序代码区--存放函数体的二进制代码

```cpp
1 例： //main.c  
2 int a=0; //全局初始化区  
3 char *p1; //全局未初始化区  
4 void main()  
5 {  
6 int b; //栈  
7 char s[]="bb"; //栈  
8 char *p2; //栈  
9 char *p3="123"; //其中，“123\0”常量区，p3在栈区 
10 static int c=0; //全局区 
11 p1=(char*)malloc(10); //10个字节区域在堆区 
12 strcpy(p1,"123"); //"123\0"在常量区，编译器 可能 会优化为和p3的指向同一块区域 
13 ｝
```

# 简述 C++ 从代码到可执行二进制文件的过程
预编译->编译->汇编->链接

其中链接分为静态链接和动态链接：
- 静态链接：在链接的时候就已把要调用的函数链接到生成的可执行文件中。
- 动态链接：在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中去找要链接的


# Queue Buffer
## 面临的问题
Queue Buffer是RDMA中数据结构Queue在内存中的形式，其面临以下问题：
1. 硬件访问内存用的是DMA地址，即IOVA或PA，并不是用户看到的VA，两者不在同一个地址空间。
2. 操作系统的换页功能会导致虚拟地址与物理地址的映射关系变化。
3. 虚拟地址连续，物理地址不一定连续。

对此，创建QP或其他Queue时，都需要陷入内核态，并进行以下操作：
1. 获取物理内存页的DMA地址。
2. 为虚拟页面映射物理页，并固定虚拟页和物理页间的关系。
3. 以硬件可以识别的方式组织物理内存页的DMA地址。

## 控制路径
### 用户态
用户首先在用户程序中调用Create QP的Verbs API来启动创建QP的流程，随后用户驱动程序会根据用户指定的Queue的深度和硬件WQE大小，申请一片虚拟内存，进而陷入内核态。

### 内核态
内核态获取到用户申请的Buffer信息后，就会开始解决上面提出的三个问题：
1. 系统提供了DMA地址映射接口，来获取物理内存页的DMA地址。
2. 利用Pin机制，将物理页固定在page buffer中，从而固定虚拟也和物理页间的关系
3. 将CPU视角下的SG Table拷贝到一片连续的物理内存中，从而RDMA网卡可以通过这块连续的物理内存得知离散的Buffer信息，结构如下：
![[Pasted image 20240121103229.png]]

通过以上步骤，我们就创建了一个Queue以及其对应的Queue Buffer
## 数据路径
### 用户态
1. 用户的应用程序通过rdma-core提供的Verbs接口来Post Send一个WR
2. 用户态驱动收到用户的WR后，按照格式配置硬件相关的WQE的内容，并放入Queue Buffer中
3. 填写完WQE之后，驱动通过Doorbell机制通知硬件获取WQE

### 内核态
1. 硬件收到Doorbell之后，会解析其内容，拿到对应的QPN和WQE头指针。
2. 通过QPN找到对应的QPC，进而获取QP Buffer内容
3. 通过WQE头指针，在QP Buffer中获取用户下发的WQE，解析后即可进行发送

# MR Buffer
## 面临的问题
RDMA网卡在读写内存时，由于绕开了内核，因而没有VA to PA的映射表，无法获取对应的物理地址。

对此我们需要注册MR，同时创建映射表，从而RDMA网卡可以直接读写内存。

## 控制路径
### 应用程序调用Verbs API
API接口如下：
```c
struct ibv_mr *ibv_reg_mr(struct ibv_pd *pd, void *addr, size_t length, int access);
// pd：MR关联的PD指针
// addr：起始虚拟地址
// length：MR长度
// access：MR的本地和远端访问权限
```

返回值是一个MR的指针，其中记录了一些MR的信息：
```c
struct ibv_mr {
    struct ibv_context *context; //进程上下文指针
    struct ibv_pd   *pd; //关联的PD指针
    void  *addr; //实际起始虚拟地址
    size_t length; //实际长度
    uint32_t handle; //内核态用于索引资源的句柄，用户不用关注
    uint32_t lkey; //L_Key
    uint32_t rkey; //R_Key
};
```

用户在应用程序中调用标准Verbs API之后，rdma-core的公共代码会调用对应设备注册的回调函数，进入用户态驱动中。而用户态驱动只是做一层对框架函数的调用，然后就陷入内核态进行下一步处理。

### 内核态操作
进入内核态后，大部分操作和Queue Buffer的创建相同：
- 获取Buffer信息
- 为虚拟页面映射物理页，并固定虚拟页和物理页间的关系
- 获取物理页的DMA地址
- 以硬件可以识别的方式组织物理内存页的DMA地址

不同的是这里还需要产生L_Key和R_Key，其格式如下：
![[Pasted image 20240121123920.png]]
- index：index部分的功能和QPN是类似的，是MR的**唯一**编号，硬件通过这个index就可以找到一个MR的MRC表项，从而进一步获取其信息。
- key：这个8bit域段才是真正用于校验的部分，一般是由驱动生成一个随机值。

# 基于Socket API的QP间建链
## 概述
QP间进行通信之前，需要知道对方的GID和QPN等信息，这些信息需要依靠建链来获得。

基于Socket API进行RDMA QP间的建链，指的就是**先在两个节点间通过Socket API建立TCP/IP的连接，然后通过这条连接来交互双方的QP信息**。

## 通过Socket连接交换信息
用户可以自行决定如何交互以及交换的信息，但通常来说有以下必须交换的信息：
- GID：全局ID，是Infiniband网络层（Network Layer）的地址，类比以太网中的IP地址
- QPN：是节点某个QP的唯一编号，类比为以太网中的端口号
- Q_Key：用于UD模式，由于没有QP间的连接，需要依靠Q_Key中的信息进行信息校验

## 通过Socket连接做同步
Socket连接除了交换信息外，还可用于QP间通信的同步，如下图：
![[Pasted image 20240122103411.png]]

# 基于CM API的QP间建链
## 为什么需要CM
Socket 建链需要网卡支持TCP/IP协议，因而运行Infiniband/RoCE v1的设备不能使用这种建链方式。iWARP协议的TCP/IP建链流程被封装到了CM API里面，因而也不能使用这种建链方式。**只有RoCE v2协议的用户才可以选择直接使用基于Socket API建链方式**。

## CM协议
RC QP的CM建链和断链流程和TCP非常相似，都是三次握手与四次挥手

UD QP的CM建链流程相对于RC要简单，只负责进行发送，是否接收以及之后的操作由上层逻辑定义。
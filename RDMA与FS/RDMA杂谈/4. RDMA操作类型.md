RDMA中有双端操作——SEND和RECV，和单端操作——WRITE和READ。

# SEND & RECV
为什么称之为“双端操作”？因为**完成一次通信过程需要两端CPU的参与**，并且收端需要提前显式的下发WQE。因而这只相当于一种加入了0拷贝和协议栈卸载的传统收发模型的“升级版”。
![[Pasted image 20240109164445.png]]

# WRITE
WRITE全称是RDMA WRITE操作，是本端主动写入远端内存的行为，除了准备阶段，远端CPU不需要参与，也不感知何时有数据写入、数据在何时接收完毕。所以这是一种单端操作。

本端在准备阶段通过数据交互，获取了对端某一片可用的内存的**地址**和“**钥匙**”，相当于获得了这片远端内存的读写权限。拿到权限之后，本端就可以像访问自己的内存一样**直接对这一远端内存区域进行读写**，这也是RDMA——远程直接地址访问的内涵所在。

![[Pasted image 20240109164548.png]]
1. 请求端APP以WQE（WR）的形式下发一次WRITE任务。
2. 请求端硬件从SQ中取出WQE，解析信息。
3. 请求端网卡根据WQE中的虚拟地址，转换得到物理地址，然后从内存中拿到待发送数据，组装数据包。
4. 请求端网卡将数据包通过物理链路发送给响应端网卡。
5. 响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，将数据放置到指定内存区域。
6. 响应端回复ACK报文给请求端。
7. 请求端网卡收到ACK后，生成CQE，放置到CQ中。
8. 请求端APP取得任务完成信息。

# READ
READ跟WRITE是相反的过程，是本端主动读取远端内存的行为。同WRITE一样，远端CPU不需要参与，也不感知数据在内存中被读取的过程。

获取key和虚拟地址的流程也跟WRITE没有区别，需要注意的是“读”这个动作所请求的数据，是在对端回复的报文中携带的。

![[Pasted image 20240109164628.png]]
1. 请求端APP以WQE的形式下发一次READ任务。
2. 请求端网卡从SQ中取出WQE，解析信息。
3. 请求端网卡将READ请求包通过物理链路发送给响应端网卡。
4. 响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，从指定内存区域取出数据。
5. 响应端硬件将数据组装成回复数据包发送到物理链路。
6. 请求端硬件收到数据包，解析提取出数据后放到READ WQE指定的内存区域中。
7. 请求端网卡生成CQE，放置到CQ中。
8. 请求端APP取得任务完成信息。


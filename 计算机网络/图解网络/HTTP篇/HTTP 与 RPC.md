# 使用纯裸 TCP 会有什么问题
TCP 是有三个特点，**面向连接**、**可靠**、基于**字节流**。

其中基于**字节流**的意思是纯裸 TCP 收发的这些 01 串之间是**没有任何边界**的，因而无法进行语义划分，这就是“粘包”问题。

对此我们需要加入一些**自定义的规则**，用于区分**消息边界**。这些规则就是具体的协议，于是基于TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。

# HTTP 和 RPC 有什么区别
## 服务发现
要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 **IP 地址和端口**。这个找到服务对应的 IP 端口的过程，其实就是**服务发现**。

在 **HTTP** 中，你知道服务的域名，就可以通过 **DNS 服务**去解析得到它背后的 IP 地址

在 **RPC** 中，就有些区别，一般会有专门的**中间服务**去保存服务名和IP信息，比如 **Consul 或者 Etcd，甚至是 Redis**。

## 底层连接形式
以主流的 **HTTP/1.1** 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（**Keep Alive**），之后的请求和响应都会复用这条连接。

而 **RPC** 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个**连接池**，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，**用完放回去，下次再复用**

## 传输的内容
TCP传输的是二进制串，因而我们的传输内容自然就是序列化后的内容。
![[Pasted image 20240120101636.png]]

HTTP和RPC的序列化方案不同：
![[Pasted image 20240120101655.png]]
![[Pasted image 20240120101659.png]]

由于 RPC 的定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，**因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。**

# 小结
总的来说，RPC只是一种框架，而不是具体的协议实现，因而RPC和HTTP实际上是不同赛道，RPC本身也可以使用HTTP实现，像是gRPC采用的就是HTTP/2的底层传输。
# HTTP基本概念
## HTTP是什么
HTTP 是超文本传输协议，也就是**H**yper**T**ext **T**ransfer **P**rotocol。

将这个定义进行扩写，我们可以给出HTTP的一句话描述：**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

## HTTP 报文常见字段
![[Pasted image 20240119163317.png]]
HTTP报文常见形式如上，常见的字段如下：

### Host 字段
客户端发送请求时，用来指定服务器的域名，形式如下：
```
Host: www.A.com
```

### Content-Length 字段
服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度，形式如下：
```
Content-Length: 1000
```

另外，Content-Length配合回车符、换行符可用于解决TCP “粘包”的问题，具体看见另一篇[文章](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)

### Connection 字段
`Connection` 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用，形式如下：
```
Connection: Keep-Alive
```

这里HTTP Keep-Alive 和 TCP Keepalive是不一样的。

### Content-Type 字段
`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

`Accept` 字段用于客户端生命自己可以接受哪些数据格式。

### Content-Encoding 字段
`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

# GET 与 POST
## GET 和 POST 有什么区别？
**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。举个例子：打开一个网站，浏览器就会发送 GET 请求给服务器，服务器就会返回网站的所有文字及资源。

**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。举个例子：在一个网站进行留言后点击「提交」，浏览器就会执行一次 POST 请求，把留言文字放进报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

## GET 和 POST 方法都是安全和幂等的吗？
安全和幂等的概念：
- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

对于GET和POST而言：
- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

# HTTP 缓存技术
对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了。

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

## 什么是强制缓存？
强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

浏览器通过`Cache-Control`这个字段实现强制缓存：
- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

## 什么是协商缓存？
**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现：
1. 通过时间进行判断：客户端第一次请求后，服务器返回一个`Last-Modified` 声明，之后客户端再次发起请求时，就会将`Last-Modified`放在请求报文的`If-Modified-Since`字段中，服务器收到后就会将其与被请求资源的最后修改时间相比较，如果一样就说明资源无更新，直接返回HTTP 304。
2. 通过唯一标识进行判断：客户端第一次请求后，服务器返回一个`Etag` 声明，之后客户端再次发起请求时，就会将`Etag`放在请求报文的`If-None-Match`字段中，服务器收到后就会将其与被请求资源的唯一标识进行判断，如果一样就说明资源无更新，直接返回HTTP 304。

结合以上两种缓存方式，总的工作流程如下图：
![[Pasted image 20240119195807.png]]

# HTTP/1.1 特性
## HTTP/1.1 的优点有哪些？
HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」：
1. 简单：HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**
2. 灵活和易于扩展：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。
3. 应用广泛和跨平台

## HTTP/1.1 的缺点有哪些？
HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。
1. 无状态双刃剑：服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，可以减轻服务器的负担。但另一方面有些功能需要服务器去追踪用户信息的状态。对此我们可以使用**Cookie** 技术。
2. 明文传输双刃剑：报文便于调试，但也意味着**信息裸奔**。
3. 不安全：HTTP的不安全可以通过HTTPS的方式进行解决。

# HTTP 与 HTTPS

# HTTP基本概念
## HTTP是什么
HTTP 是超文本传输协议，也就是**H**yper**T**ext **T**ransfer **P**rotocol。

将这个定义进行扩写，我们可以给出HTTP的一句话描述：**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

## HTTP 报文常见字段
![[Pasted image 20240119163317.png]]
HTTP报文常见形式如上，常见的字段如下：

### Host 字段
客户端发送请求时，用来指定服务器的域名，形式如下：
```
Host: www.A.com
```

### Content-Length 字段
服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度，形式如下：
```
Content-Length: 1000
```

另外，Content-Length配合回车符、换行符可用于解决TCP “粘包”的问题，具体看见另一篇[文章](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)

### Connection 字段
`Connection` 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用，形式如下：
```
Connection: Keep-Alive
```

这里HTTP Keep-Alive 和 TCP Keepalive是不一样的。

### Content-Type 字段
`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

`Accept` 字段用于客户端生命自己可以接受哪些数据格式。

### Content-Encoding 字段
`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

# GET 与 POST
## GET 和 POST 有什么区别？
**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。举个例子：打开一个网站，浏览器就会发送 GET 请求给服务器，服务器就会返回网站的所有文字及资源。

**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。举个例子：在一个网站进行留言后点击「提交」，浏览器就会执行一次 POST 请求，把留言文字放进报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

## GET 和 POST 方法都是安全和幂等的吗？
安全和幂等的概念：
- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

对于GET和POST而言：
- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

# HTTP 缓存技术
对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了。

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

## 什么是强制缓存？
强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

浏览器通过`Cache-Control`这个字段实现强制缓存：
- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

## 什么是协商缓存？
**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现：
1. 通过时间进行判断：客户端第一次请求后，服务器返回一个`Last-Modified` 声明，之后客户端再次发起请求时，就会将`Last-Modified`放在请求报文的`If-Modified-Since`字段中，服务器收到后就会将其与被请求资源的最后修改时间相比较，如果一样就说明资源无更新，直接返回HTTP 304。
2. 通过唯一标识进行判断：客户端第一次请求后，服务器返回一个`Etag` 声明，之后客户端再次发起请求时，就会将`Etag`放在请求报文的`If-None-Match`字段中，服务器收到后就会将其与被请求资源的唯一标识进行判断，如果一样就说明资源无更新，直接返回HTTP 304。

结合以上两种缓存方式，总的工作流程如下图：
![[Pasted image 20240119195807.png]]

# HTTP/1.1 特性
## HTTP/1.1 的优点有哪些？
HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」：
1. 简单：HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**
2. 灵活和易于扩展：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。
3. 应用广泛和跨平台

## HTTP/1.1 的缺点有哪些？
HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。
1. 无状态双刃剑：服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，可以减轻服务器的负担。但另一方面有些功能需要服务器去追踪用户信息的状态。对此我们可以使用**Cookie** 技术。
2. 明文传输双刃剑：报文便于调试，但也意味着**信息裸奔**。
3. 不安全：HTTP的不安全可以通过HTTPS的方式进行解决。

# HTTP 与 HTTPS
## HTTP 与 HTTPS 有哪些区别？
- HTTP是明文传输，而HTTPS是加密传输
- HTTP采用明文传输，连接建立简单。HTTPS采用加密传输，连接建立复杂。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## HTTPS 解决了 HTTP 的哪些问题？
HTTP对应的三个风险被HTTPS分别解决：
- **窃听风险**->**信息加密**：**混合加密**
- **篡改风险**->**校验机制**：**摘要算法**
- **冒充风险**->**身份证书**：**数字证书**

### 混合加密
HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：
- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：
- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

### 摘要算法+数字签名
HTTPS采用摘要算法计算传输数据的哈希值，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

为了避免这种情况，计算机里会用**非对称加密算法**来解决，对公钥和私钥的使用不同，对应目的也不同：
- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

因而**数字签名**的生成方式就是采用私钥对哈希值进行加密，另一端使用公钥对哈希值进行解密，就可以证明数据没有被篡改。

### 数字证书
HTTPS采用**数字证书**证明发出的公钥就是自己的，整体流程如下图：
![[Pasted image 20240119203113.png]]

## HTTPS 是如何建立连接的？其间交互了什么？
HTTPS采用SSL/TLS 协议来建立连接，其基本流程如下：
- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法](https://xiaolincoding.com/network/2_http/https_rsa.html)和 [ECDHE 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。

基于RSA算法的TLS握手过程如下：
![[Pasted image 20240119204406.png]]
总的来说，客户端和服务器之间通过四次握手交换得到三个随机数，其中只有pre-master是经过加密的。通过这三个随机数生成一个会话密钥，并在最后两次握手的过程中确定之后都采用该会话密钥进行通信。

## HTTPS 的应用数据是如何保证完整性的？
TLS 在实现上分为**握手协议**和**记录协议**两层：
- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：
![[Pasted image 20240119205306.png]]
具体过程如下：
- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

# HTTP/1.1、HTTP/2、HTTP/3 演变
## HTTP/1.1 相比 HTTP/1.0 提高了什么性能？
HTTP/1.1 相比 HTTP/1.0 性能上的改进：
- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：
- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

## HTTP/2 做了什么优化？
HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

 HTTP/2 相比 HTTP/1.1 性能上的改进：
- 头部压缩：如果同时发出多个请求，且头部是一样或相似的，那么协议**消除重复的部分**。
- 二进制格式：HTTP/1.1是纯文本传输，HTTP/2直接将数据转化为二进制
- 并发传输：引入 Stream 概念，多个 Stream 复用在一条 TCP 连接
- 服务器主动推送资源：服务端不再是被动地响应，可以**主动**向客户端发送消息。

**HTTP/2缺点**
HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

## HTTP/3 做了哪些优化？
HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：
- HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**
- HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

为解决HTTP/2的TCP层队头阻塞问题，**HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。由于 UDP 是不可靠传输的，需要使用基于 UDP 的 **QUIC 协议** 来实现类似 TCP 的可靠性传输。（实际上就是在应用层中实现可靠性传输）

QUIC 有以下 3 个特点。
- 无队头阻塞：多个Stream在 QUIC 连接上复用，某个流发生丢包了，只会影响该流，其他流不受影响。
- 更快的连接建立
- 连接迁移

总的来说，QUIC 是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。


# TCP 连接建立
## TCP 三次握手过程是怎样的？
流程图如下，包含三个报文：
- SYN
- SYN + ACK
- ACK+数据（ACK的同时已经可以携带数据了）
![[Pasted image 20240129112350.png]]

## 为什么是三次握手？不是两次、四次？
三次握手的原因：
- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

### 原因一：避免历史连接
**我们先看为什么两次握手无法避免历史连接：**
1. 在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态
2. 假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接
3. 而由于服务端无法得知历史连接，只有收到RST报文时才能知道这是历史连接
![[Pasted image 20240129112829.png]]

**接下来看为什么三次握手可以避免历史连接：**
三次握手为服务端提供了一个中间状态，从而可以阻止历史连接的发生。
![[Pasted image 20240129113003.png]]

### 原因二：同步双方初始序列号
TCP 协议的通信双方， 都必须维护一个「序列号」进行报文的保序。序列号通过SYN报文传递，并通过ACK报文确定。通信双方都要有这样一个来回，才能确保收到对方的初始序列号。

事实上四次握手是最直观的上述实现方式，但第二步和第三步可以进行合并，从而提高效率：
![[Pasted image 20240129113448.png]]

### 原因三：避免资源浪费
这主要是针对二次握手可能出现的情况，出现历史连接时，服务端就会建立多个冗余的连接，从而造成资源的浪费。

## 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
主要原因是，为了防止历史报文被下一个相同四元组的连接接收。如下图：
![[Pasted image 20240129113817.png]]

如果每次连接的初始序列号不同，就可以**大概率避免历史报文被错误地接收**。如果要完全避免，还需要依靠时间戳的机制。

初始序列号ISN的生成方法如下：
- ISN = M + F(localhost, localport, remotehost, remoteport)。
- `M` 是一个计时器，这个计时器每隔 4 微秒加 1。
- `F` 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。

## 握手丢失时，会发生什么
首先我们确定两点：
- ACK报文不会重传
- 主动发送的报文在未收到ACK后，超时并重传

因而对于三次握手的每一种丢失，都有对应的方案：
- 一次握手丢失：没收到ACK，会自行重传
- 二次握手丢失：由于二次握手既是一个ACK也是一个SYN，因而会有以下两种情况：
	- 客户端由于没收到ACK，会重传SYN
	- 服务端没收到客户端的ACK，会重传SYN+ACK
- 三次握手丢失：由于本身是ACK，只有服务端感知到超时后才会重传SYN+ACK

## 什么是 SYN 攻击？如何避免 SYN 攻击？
假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。
![[Pasted image 20240129115035.png]]

避免SYN攻击，有以下四种方法：
- 调大 netdev_max_backlog；
- 增大 TCP 半连接队列；
- 开启 tcp_syncookies；
- 减少 SYN+ACK 重传次数

### 方式一：调大 netdev_max_backlog
netdev_max_backlog是网卡接收数据包的缓存队列大小，可以增大该值，从而在内核处理不了那么多数据包时进行缓存

### 方式二：增大 TCP 半连接队列
这个就是直接增大半连接队列的大小

### 方式三：开启 net.ipv4.tcp_syncookies
开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。

在接收到客户端的第一次握手后，服务端通过算法计算一个`cookie`值放入第二次握手报文中，客户端在第三次握手时携带该`cookie`值，这样服务端就知道这是第三次握手，可以直接放入Accept队列，这样就绕开了半连接队列的存储。

### 方式四：减少 SYN+ACK 重传次数
通过减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

# TCP 连接断开
## TCP 四次挥手过程是怎样的？
![[Pasted image 20240130122850.png]]
- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

## 为什么挥手需要四次？
- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

## 挥手丢失时，会发生什么
依旧是确定两点：
- ACK报文不会重传
- 主动发送的报文在未收到ACK后，超时并重传

因而整体流程与建立连接时的挥手丢失基本相同

## 为什么 TIME_WAIT 等待的时间是 2MSL？
`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**。`TTL`是 IP 数据报可以经过的最大路由数。这两者的关系是： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

## 为什么需要 TIME_WAIT 状态？
主动发起关闭连接的一方，才会有 `TIME-WAIT` 状态。

需要 TIME-WAIT 状态，主要是两个原因：
- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
- 保证「被动关闭连接」的一方，能被正确的关闭；

## TIME_WAIT 过多有什么危害？
过多的 TIME-WAIT 状态主要的危害有两种：
- 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
- 第二是占用端口资源，端口资源也是有限的

**如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多**，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了（内核根据四元组进行定位）

**如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多**，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接

## 如何优化 TIME_WAIT？
这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：
- 打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项：**复用处于 TIME_WAIT 的 socket 为新的连接所用**。
- net.ipv4.tcp_max_tw_buckets：**当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置**
- 程序中使用 SO_LINGER ，应用强制使用 RST 关闭：**调用`close`后，会立该发送一个`RST`标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了`TIME_WAIT`状态，直接关闭。**

## 服务器出现大量 TIME_WAIT 状态的原因有哪些？
首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明**服务器主动断开了很多 TCP 连接**：
- 第一个场景：HTTP 没有使用长连接
- 第二个场景：HTTP 长连接超时
- 第三个场景：HTTP 长连接的请求数量达到上限

## 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。

所以，**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**。我们需要排查代码来找到问题。

一个普通的 TCP 服务端的流程如下，问题就可能出现在以下步骤中：
1. 创建服务端 socket，bind 绑定端口、listen 监听端口
2. 将服务端 socket 注册到 epoll
3. epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket
4. 将已连接的 socket 注册到 epoll
5. epoll_wait 等待事件发生
6. 对方连接关闭时，我方调用 close

## 如果已经建立了连接，但是客户端突然出现故障了怎么办？
客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 `ESTABLISH` 状态，占用着系统资源。

为了解决这个问题，TCP有一个**保活机制**：
- 定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

## 如果已经建立了连接，但是服务端的进程崩溃会发生什么？
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。


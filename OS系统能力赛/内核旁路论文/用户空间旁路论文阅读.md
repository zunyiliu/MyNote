# Abstract
进行系统调用时会发生上下文的切换，这个过程非常花时间，因而严重影响了系统调用密集型程序的性能，尤其是那些I/O密集型的应用程序。

为了解决这个问题，之前的很多工作集中在将系统调用从I/O路径上移除，通过将驱动程序和应用程序放在同一空间或同一作业批次来实现。这样做就要求开发者对他们的应用程序修改，甚至需要对硬件进行更新，因而阻碍了广泛的使用。

在这篇论文中，我们使用用户空间旁路（userspace bypass）的方式，通过将用户空间中的指令透明地移动到内核中来实现程序的加速。这样做的好处是不需要修改应用程序，实现了修改与用户空间程序的二进制兼容。**具体而言，内核识别连续系统调用之间的短用户空间执行路径，并通过基于软件的故障隔离（SFI）保证，将该路径中的指令转换为代码块。**（这块不是很明确）

# 1 Introduction
**Syscall-refactoring approaches**
在最近的工作中，主要有两种方式通过改变I/O路径处理系统调用来实现更好的性能（I/O requests Per Second (IOPS)），我们称这些方法为syscall-refactoring approaches：
1. 第一种方法通过将数据处理逻辑放到内核或将设备驱动放到用户空间，都是将数据处理与I/O工作放到同一空间中，这样数据处理逻辑就可以直接调用设备，避免了上下文的切换
2. 第二种方法是将多个I/O系统调用组合成一个系统调用，从而减少上下文切换次数。

然而这两种方法都要求开发者修改他们的程序。

**Our approach**
在本文中，我们提出了*userspace bypass*（用户空间旁路，简称UB），减少系统调用的开销并实现了*binary compatibility*（二进制兼容性），这样就不需要修改用户程序。

UB的动机是发现具备高IOPS的应用程序中，两个连续的系统调用之间不会有太多的指令，因而可以在遵守安全性的前提下，将这些指令转化成代码块，在内核空间中执行，这样就不用返回用户空间，也就**减少了上下文切换**，如下图：
![[Pasted image 20240304202012.png]]

然而，也有一些挑战应该得到解决：
- 首先，只有那些可能在频繁调用的连续系统尺度之间执行的指令才应该被用户空间绕过。但是，如果没有开发人员提供明确的信息，就很难找到这样的序列。由于将指令提升到内核也会引入开销，因此需要仔细选择要优化的系统尺度来抵消这种开销。
- 其次，恶意的应用程序可能会利用UB来窃取内核数据，甚至会执行特权指令。
- 此外，有问题的应用程序可能会污染内核内存，需要保证内核的安全。
- 最后，为了实现二进制兼容性，提升的应用程序代码应该忽略它们是在内核模式还是在用户模式下执行。应该保证有UB和没有UB能得到相同的执行结果，包括内存顺序和多线程应用程序的原子性。

我们采用*Dynamic Binary Translation DBT*和*Software-Based Fault Isolation*技术来解决这些问题：
- 首先我们挂起所有系统调用，来分析哪些系统调用最频繁
- 其次，受*Just-In-Time (JIT) compilation*的启发，我们可以在获取紧跟在系统调用后的用户空间中的指令
- 接着将这些指令转换为二进制翻译缓存（BTC）。接下来，我们迭代地执行BTC，并从退出指令扩展BTC，直到遇到下一个系统调调用。（没太看懂）
- UB不会修改指令顺序，因而其他线程可以安全地和UB优化的线程并行运行。

本文实现了UB的原型，并进行了测试，效果省略。。。

最后总结本文的贡献：
- 我们提出了用户空间旁路(UB)，它在内核模式下直接执行系统调用之间的指令，以加速系统调用。
- 我们提供了一个具体的设计，可以透明地将用户空间指令转换为内核安全的BTC。使用这种方法，现有的应用程序可以在不修改的情况下执行，并享受性能增益。
- 我们实现了一个原型，并对几个高IOPS应用程序进行了评估，结果证明了UB的有效性。

# 2 Background
在本节中，我们首先概述系统调用机制及其引入的开销。然后，我们描述了之前工作在减少开销方面所做的努力。

## 2.1 Syscalls and Their Costs
系统调用是内核提供的一个供应用程序调用的接口，可以将控制权从用户空间转移到内核空间，从而提供所需的服务。

系统调用需要进行上下文的切换，这一点很花时间，之后的篇幅都是在这方面具体介绍。

## 2.2 Performance Optimization on Syscalls
我们介绍几种优化系统调用性能的方法，并于UB做比较
- Asynchronous syscalls（异步系统调用）：异步就是更快，但是目前大部分都还是同步的系统调用
- Syscall batching：将多个系统调用组合到一起
- Unikernel：直接选择在内核空间中运行用户应用程序
- In-kernel sandbox：内核沙箱允许用户应用程序执行一些特权指令，
- Kernel bypass：内核旁路，有些操作不需要内核参与，比如I/O操作，可以在用户空间中接管I/O设备，就不需要经过内核，比如DPDK就是这样的。

这些方法都需要修改用户程序，不具有广泛适用性。

# 3 Design Overview
为了解决上述问题，我们提出了用户空间旁路（UB）。UB旨在实现以下三个设计目标（DG）：
- DG1：最小化开发者的修改成本
- DG2：最小化系统架构的修改
- DG3：实现和*syscall-refactoring approaches*相近的优化效果

## 3.1 Syscall-intensive Applications
我们专注于优化高IOPS的应用程序，例如，Redis和Nginx，它们也是系统密集型的。通过分析它们的代码和运行时行为，我们确定了以下指导UB设计的两个见解：

**Lightweight userspace instructions in I/O threads.**
我们发现I/O线程中的计算指令很少，可能是因为这些程序将计算和I/O线程进行了划分
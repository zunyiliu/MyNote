# Abstract
进行系统调用时会发生上下文的切换，这个过程非常花时间，因而严重影响了系统调用密集型程序的性能，尤其是那些I/O密集型的应用程序。

为了解决这个问题，之前的很多工作集中在将系统调用从I/O路径上移除，通过将驱动程序和应用程序放在同一空间或同一作业批次来实现。这样做就要求开发者对他们的应用程序修改，甚至需要对硬件进行更新，因而阻碍了广泛的使用。

在这篇论文中，我们使用用户空间旁路（userspace bypass）的方式，通过将用户空间中的指令透明地移动到内核中来实现程序的加速。这样做的好处是不需要修改应用程序，实现了修改与用户空间程序的二进制兼容。**具体而言，内核识别连续系统调用之间的短用户空间执行路径，并通过基于软件的故障隔离（SFI）保证，将该路径中的指令转换为代码块。**（这块不是很明确）

# Introduction
**Syscall-refactoring approaches**
在最近的工作中，主要有两种方式通过改变I/O路径处理系统调用来实现更好的性能（I/O requests Per Second (IOPS)），我们称这些方法为syscall-refactoring approaches：
1. 第一种方法通过将数据处理逻辑放到内核或将设备驱动放到用户空间，都是将数据处理与I/O工作放到同一空间中，这样数据处理逻辑就可以直接调用设备，避免了上下文的切换
2. 第二种方法是将多个I/O系统调用组合成一个系统调用，从而减少上下文切换次数。

然而这两种方法都要求开发者修改他们的程序。

**Our approach**
在本文中，我们提出了*userspace bypass*（用户空间旁路，简称UB），减少系统调用的开销并实现了*binary compatibility*（二进制兼容性），这样就不需要修改用户程序。

UB的动机是发现具备高IOPS的应用程序中，两个连续的系统调用之间不会有太多的指令，因而可以在遵守安全性的前提下，将这些指令转化成代码块，在内核空间中执行，这样就不用返回用户空间，也就**减少了上下文切换**，如下图：
![[Pasted image 20240304202012.png]]

然而，也有一些挑战应该得到解决：
- 首先，只有那些可能在频繁调用的连续系统尺度之间执行的指令才应该被用户空间绕过。但是，如果没有开发人员提供明确的信息，就很难找到这样的序列。由于将指令提升到内核也会引入开销，因此需要仔细选择要优化的系统尺度来抵消这种开销。
- 其次，恶意的应用程序可能会利用UB来窃取内核数据，甚至会执行特权指令。
- 此外，有问题的应用程序可能会污染内核内存，需要保证内核的安全。
- 最后，为了实现二进制兼容性，提升的应用程序代码应该忽略它们是在内核模式还是在用户模式下执行。应该保证有UB和没有UB能得到相同的执行结果，包括内存顺序和多线程应用程序的原子性。

我们采用*Dynamic Binary Translation DBT*和*Software-Based Fault Isolation*技术来解决这些问题：
- 首先我们挂起所有系统调用，来分析哪些系统调用最频繁
- 其次，受*Just-In-Time (JIT) compilation*的启发，我们可以在获取紧跟在系统调用后的用户空间中的指令
- 接着将这些指令转换为二进制翻译缓存（BTC）。接下来，我们迭代地执行BTC，并从退出指令扩展BTC，直到遇到下一个系统调调用。


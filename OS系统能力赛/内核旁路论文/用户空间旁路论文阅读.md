# Abstract
进行系统调用时会发生上下文的切换，这个过程非常花时间，因而严重影响了系统调用密集型程序的性能，尤其是那些I/O密集型的应用程序。

为了解决这个问题，之前的很多工作集中在将系统调用从I/O路径上移除，通过将驱动程序和应用程序放在同一空间或同一作业批次来实现。这样做就要求开发者对他们的应用程序修改，甚至需要对硬件进行更新，因而阻碍了广泛的使用。

在这篇论文中，我们使用用户空间旁路（userspace bypass）的方式，通过将用户空间中的指令透明地移动到内核中来实现程序的加速。这样做的好处是不需要修改应用程序，实现了修改与用户空间程序的二进制兼容。**具体而言，内核识别连续系统调用之间的短用户空间执行路径，并通过基于软件的故障隔离（SFI）保证，将该路径中的指令转换为代码块。**（这块不是很明确）

# 1 Introduction
**Syscall-refactoring approaches**
在最近的工作中，主要有两种方式通过改变I/O路径处理系统调用来实现更好的性能（I/O requests Per Second (IOPS)），我们称这些方法为syscall-refactoring approaches：
1. 第一种方法通过将数据处理逻辑放到内核或将设备驱动放到用户空间，都是将数据处理与I/O工作放到同一空间中，这样数据处理逻辑就可以直接调用设备，避免了上下文的切换
2. 第二种方法是将多个I/O系统调用组合成一个系统调用，从而减少上下文切换次数。

然而这两种方法都要求开发者修改他们的程序。

**Our approach**
在本文中，我们提出了*userspace bypass*（用户空间旁路，简称UB），减少系统调用的开销并实现了*binary compatibility*（二进制兼容性），这样就不需要修改用户程序。

UB的动机是发现具备高IOPS的应用程序中，两个连续的系统调用之间不会有太多的指令，因而可以在遵守安全性的前提下，将这些指令转化成代码块，在内核空间中执行，这样就不用返回用户空间，也就**减少了上下文切换**，如下图：
![[Pasted image 20240304202012.png]]

然而，也有一些挑战应该得到解决：
- 首先，只有那些可能在频繁调用的连续系统尺度之间执行的指令才应该被用户空间绕过。但是，如果没有开发人员提供明确的信息，就很难找到这样的序列。由于将指令提升到内核也会引入开销，因此需要仔细选择要优化的系统尺度来抵消这种开销。
- 其次，恶意的应用程序可能会利用UB来窃取内核数据，甚至会执行特权指令。
- 此外，有问题的应用程序可能会污染内核内存，需要保证内核的安全。
- 最后，为了实现二进制兼容性，提升的应用程序代码应该忽略它们是在内核模式还是在用户模式下执行。应该保证有UB和没有UB能得到相同的执行结果，包括内存顺序和多线程应用程序的原子性。

我们采用*Dynamic Binary Translation DBT*和*Software-Based Fault Isolation*技术来解决这些问题：
- 首先我们挂起所有系统调用，来分析哪些系统调用最频繁
- 其次，受*Just-In-Time (JIT) compilation*的启发，我们可以在获取紧跟在系统调用后的用户空间中的指令
- 接着将这些指令转换为二进制翻译缓存（BTC）。接下来，我们迭代地执行BTC，并从退出指令扩展BTC，直到遇到下一个系统调调用。（没太看懂）
- UB不会修改指令顺序，因而其他线程可以安全地和UB优化的线程并行运行。

本文实现了UB的原型，并进行了测试，效果省略。。。

最后总结本文的贡献：
- 我们提出了用户空间旁路(UB)，它在内核模式下直接执行系统调用之间的指令，以加速系统调用。
- 我们提供了一个具体的设计，可以透明地将用户空间指令转换为内核安全的BTC。使用这种方法，现有的应用程序可以在不修改的情况下执行，并享受性能增益。
- 我们实现了一个原型，并对几个高IOPS应用程序进行了评估，结果证明了UB的有效性。

# 2 Background
在本节中，我们首先概述系统调用机制及其引入的开销。然后，我们描述了之前工作在减少开销方面所做的努力。

## 2.1 Syscalls and Their Costs
系统调用是内核提供的一个供应用程序调用的接口，可以将控制权从用户空间转移到内核空间，从而提供所需的服务。

系统调用需要进行上下文的切换，这一点很花时间，之后的篇幅都是在这方面具体介绍。

## 2.2 Performance Optimization on Syscalls
我们介绍几种优化系统调用性能的方法，并于UB做比较
- Asynchronous syscalls（异步系统调用）：异步就是更快，但是目前大部分都还是同步的系统调用
- Syscall batching：将多个系统调用组合到一起
- Unikernel：直接选择在内核空间中运行用户应用程序
- In-kernel sandbox：内核沙箱允许用户应用程序执行一些特权指令，
- Kernel bypass：内核旁路，有些操作不需要内核参与，比如I/O操作，可以在用户空间中接管I/O设备，就不需要经过内核，比如DPDK就是这样的。

这些方法都需要修改用户程序，不具有广泛适用性。

# 3 Design Overview
为了解决上述问题，我们提出了用户空间旁路（UB）。UB旨在实现以下三个设计目标（DG）：
- DG1：最小化开发者的修改成本
- DG2：最小化系统架构的修改
- DG3：实现和*syscall-refactoring approaches*相近的优化效果

## 3.1 Syscall-intensive Applications
我们专注于优化高IOPS的应用程序，例如，Redis和Nginx，它们也是系统密集型的。通过分析它们的代码和运行时行为，我们确定了以下指导UB设计的两个观点：

**Lightweight userspace instructions in I/O threads.**
我们发现I/O线程中的计算指令很少，可能是因为这些程序将计算和I/O线程进行了划分，例如Redis就是主线程将accepted sockets分发给各个I/O线程，而由主线程进行计算工作。

**Amplified direct and indirect costs.**
第2.1节概述了系统调用的直接和间接成本，这些成本可以在系统调用密集型应用中被放大。

## 3.2 UB Modules
基于上述考虑，我们在设计UB时能够检测到系统调用的出现，并通过二进制转换将连续系统调用之间的用户空间指令提升到内核。Figure 1说明了我们的想法。尽管这个想法在高级上看起来很简单，但应该解决一些挑战，使UB能够实现成熟的应用程序。
- 应用程序代码不可信，需要做一定程度的隔离
- 考虑到隔离会产生额外的成本，转换每一块用户空间指令并不总是有益的，我们需要设计一种方法来确定需要转移到内核的用户空间指令

UB通过以下三个组件来解决这些挑战：
1. “热”系统调用识别器：监视目标应用程序的执行，并确定何时将用户空间指令提升到内核
2. Just-in-Time（JIT）翻译器：将用户空间指令转化成使用隔离策略的BTC（Binary Translation Cache）
3. 内核BTC执行器：用于执行转化后的BTC

UB的主要模块如下：
![[Pasted image 20240305191428.png]]
**Hot syscall identifier**
这个模块工作在内核空间中。他会分析哪些系统调用是“hot”的，比如那些大概率会紧跟另一个系统调用的；我们会将之间的用户空间指令提升到内核空间。

**BTC translator**
BTC 翻译器将上述提升到内核的用户空间指令转化成BTC，并交给BTC执行器，在这个过程中会对其进行安全化处理。

上述提到的过程都不会立刻生效，而是等到下一次遇到同样的路径时才会进行加速。

除此以外，我们还考虑加速一连串的“hot”系统调用，我们称其为*fast path*，具体在后面讲述

# 4 Hot Syscall Identifier
**Criteria of userspace bypassing.**
使用UB的标准是，其提升到内核执行带来的效益超过BTC转化的负担时，我们就应该使用UB。

**Module design**
这个模块用于找到“hot” 系统调用，主要就是两个连续系统调用之间的指令少于某个阈值时，就可以认定。以下是具体步骤：
- Syscall sampling：我们不能对所有系统调用进行监控，因而我们选取系统调用数量多的线程进行监控（例如I/O线程），在实验中这个阈值应该是100K syscall per second
- Coarse-grained profiling：进一步筛选，依旧是具有高系统调用次数的线程才能进入下一步
- Fine-grained profiling：我们筛选那些调用次数达到900的系统调用，将期间的用户空间指令交给BTC 翻译器。

# 5 BTC Runtime and Translator
在本节中，我们将描述BTC转换器如何将用户空间指令转换为内核BTC并满足安全要求。

我们的BTC翻译器遵循动态二进制翻译（DBT）的过程。

## 5.1 BTC Runtime
翻译后的代码块由内核中的BTC运行时执行。BTC运行时在内核堆栈中保存本地变量，其中包含：
- 内核上下文
- 寄存器值
- 间接跳转地址信息

BTC执行时可以访问用户空间内存，因此所有修改都会保存，寄存器修改也会在返回用户空间时固定。

## 5.2 BTC Translator
下面我们将描述如何将安全策略插入到用户空间代码中。

我们假设用户空间代码是不可信的，它可能包含任意的代码和数据，其副作用包括对内核内存的非中介访问、特权函数等。UB的目标是确保用户空间代码在被提升到内核后不能获得更多的特权（并造成更多的伤害），即保护内核的控制流的完整性。

### 5.2.1 Jump Sanitation
整个内核内存空间对UB下的高级用户空间代码开放。因此，我们采取了不同的方法来清理跳转。

**Direct jump**
为了防止BTC中的代码跳转到任意地址，只有在跳转目标已知时才会进行转换。换句话说，只有处理已知的目标的直接跳跃。

**Indirect jump**
用户空间快速路径可能包含间接的跳转，我们阻止BTC处理这样的路径，直到目标已知。特别是，当首先遇到相关的代码时，转换器会将目标与目标地址表进行比较。如果目标地址不在表中，则控制流将退出BTC运行时。当在执行BTC块时触发这样种退出时，BTC运行时将跳转指令地址（即地址的RIP）和目标地址发送给BTC转换器，并扩展快速路径

以下是一个示例：
![[Pasted image 20240305203625.png]]
BTC学习P1和P2跳转目标，并将其加入到目标地址表。经过不断的学习，BTC最终获得整个fast path。

### 5.2.2 Register Remapping
为了保护内核寄存器和堆栈，BTC转换器不允许BTC代码访问堆栈寄存器（即RSP、RBP和RIP）。此外，一些寄存器是为BTC运行时保留的，也不能被BTC代码访问。因此，我们开发了这个模块来管理寄存器。

具体来说，BTC转换器使用BTC中的M个保留寄存器来服务于对N个寄存器的潜在访问（N=M +3，3用于堆栈寄存器）。作为M < N，翻译器需要调度寄存器。N个寄存器的值存储在局部变量中，转换器从M个保留寄存器中选择一个，暂时作为一个具有重命名的特殊寄存器。转换器还插入代码以将N个寄存器同步到堆栈上的本地变量。因此，BTC代码的行为与用户空间中的快速路径相同。

### 5.2.3 Instruction Sanitization
特权指令（例如，sysret）不允许出现在BTC中，以避免利用UB的恶意代码导致的特权升级。在翻译过程中，如果内核包含任何特权指令，翻译器将避免将快速路径提升到内核。

由于寄存器重新映射，一些指令必须被重写。对于像PUSH/POP这样的堆栈操作指令，翻译器用多个指令替换它们。

### 5.2.4 Memory Access Sanitization
为了防止对内核内存的未经授权的访问，转换器将检查所有内存访问指令，只有用户空间地址是允许访问的。

## 5.3 Security Guarantees
翻译后的BTC具有以下安全属性（称为SP），它们共同使UB在内核上实现了SFI策略。

**SP1: Kernel control-flow integrity (CFI) for BTC.**
当BTC运行时将控制流传递到用户空间时，执行将只会通过退出点终止。更重要的是，当运行时执行BTC时，线程不能跳转到转换器未知的位置。因此，BTC可以防止恶意代码在内核控制流被升级后劫持它。

**SP2: Kernel data (memory and register) integrity**
对于内核上下文（或寄存器），我们将BTC运行时设计为与调用约定兼容，调用者（内核）上下文在跳转到BTC之前保存在堆栈上，在返回内核指令之前恢复。上下文切换是轻量级的，因为它不会导致特权转移。

**SP3: No privileged instructions in BTC**

**SP4: Dead loop break**
我们还考虑了针对系统资源可用性的攻击和错误。例如，用户空间应用程序可能会因为bug或故意的而陷入死循环。作为一种对策，翻译器在BTC运行时中维护一个计数器，以跟踪已经执行的指令的数量。一旦计数器超过了一个阈值，执行流就可以退出到运行时，然后再返回到用户空间，这就避免了内核被BTC代码阻塞。

## 5.4 Thread Safety
应该特别注意多线程用户空间应用程序，因为UB除了提升到内核的线程之外，无法控制其他线程。必须保留内存顺序和原子性，以避免数据竞争。幸运的是，线程安全会由翻译器自动保证，我们将在下面解释。

**Memory order.**
为了保持内存顺序，转换器将所有的用户空间内存都看作是易失性的，并且只在用户空间指令之间插入指令，而没有优化块

**Atomicity**
当使用多个指令模拟一个用户空间指令时，转换器采取特殊措施来保证原子性。在翻译一条指令时，翻译器更倾向于使用与原始指令具有相同操作码的一条指令。因此，原始指令的原子性被自动保留。

# 6 Evaluation
我们为Linux内核5.4.44实现了UB的原型。**BTC运行时是一个包含416行C代码的内核模块**，它连接着系统查询的尾声来进行系统查询识别和管理BTC运行时。**翻译器在用户空间用786行Python代码实现**（除去依赖的Python反汇编器和gcc汇编程序为），它通过sys文件与BTC运行时内核模块通信。内核通过向系统共享条目添加6行代码来修改，以允许模块钩接syscall。


# 三大问题
1. 脏读：即写读冲突，读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。
2. 不可重复读：即读写冲突，在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。
3. 幻读：假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用

# 事务隔离级别
SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：
1. 读未提交（READ UNCOMMITTED）
2. 读提交 （READ COMMITTED）
3. 可重复读 （REPEATABLE READ）
4. 串行化 （SERIALIZABLE）

4种隔离标准对上述三个问题的解决情况如下：
![[Pasted image 20240301152435.png]]

# MySQL 中是如何实现事务隔离的
- 读未提交：不加任何锁，性能最好
- 串行化：读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。性能最差
- 读提交、可重复读：采用MVCC的方式解决+读写锁
	- 可重复读仅在事务开始是创建一次快照
	- 读提交每次执行select语句的时候都要重新创建一次快照

此外，MySQL默认隔离级别是可重复读，但MySQL采用了其他的方式减小了幻读的出现，即**间隙锁**的使用

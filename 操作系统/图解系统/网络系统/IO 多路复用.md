# 基本Socket模型
一个Socket就对应了一个连接，基本的Socket模型可以分为多进程模型和多线程模型。

## 多进程模型
**多进程模型**，也就是为每个客户端分配一个进程来处理请求。

服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 `fork()` 函数创建一个子进程，由子进程来处理该连接，父进程将会等待子进程处理完成。
![[Pasted image 20240115112414.png]]

每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，因而这种模型无法支撑C10K的服务器。

## 多线程模型
线程是轻量级的进程，所占据的系统资源和线程间上下文切换的包袱都会更少。

**多线程模型**和多进程模型原理相同，由于采用线程，所耗费的资源会更少，但仍需要为每个连接配置一个线程，这同样无法支撑C10K的服务器。

# I/O多路复用
既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 **I/O 多路复用**技术。

select/poll/epoll 是内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

## select/poll
select 实现多路复用的方式是：
1. 用户程序将已连接的 Socket 都放到一个**文件描述符集合**
2. 调用 select 函数将文件描述符集合**拷贝**到内核里，内核通过遍历集合的方式判断一个Socket是否可读或者可写，并打上标记。
3. 内核把整个文件描述符集合**拷贝**回用户态里
4. 用户态再次**遍历**集合找到可读或可写的 Socket，然后再对其处理。

整个过程需要 **2 次「遍历」文件描述符集合**，**2 次「拷贝」文件描述符集合**。

select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

poll使用动态数组，以链表形式来组织文件描述符，可以突破 select 的文件描述符个数限制。其他方式与select相同。

总的来说，select和poll都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

## epoll
epoll的使用场景如下，先用epoll_create 创建一个 epoll对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。
```cpp
int s = socket(AF_INET, SOCK_STREAM, 0);
bind(s, ...);
listen(s, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

while(1) {
    int n = epoll_wait(...);
    for(接收到数据的socket){
        //处理
    }
}
```

epoll有两个优势：
1. epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，增删改一般时间复杂度是 `O(logn)`，避免了`O(n)`的维护成本。
2.  epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中。当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。
![[Pasted image 20240115124932.png]]

## 边缘触发与水平触发
epoll 支持两种事件触发模式，分别是边缘触发（_edge-triggered，ET_）和水平触发（_level-triggered，LT_）
- 边缘触发：当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**
- 当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**

一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。


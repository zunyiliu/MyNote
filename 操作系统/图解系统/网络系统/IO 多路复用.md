# 基本Socket模型
一个Socket就对应了一个连接，基本的Socket模型可以分为多进程模型和多线程模型。

## 多进程模型
**多进程模型**，也就是为每个客户端分配一个进程来处理请求。

服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 `fork()` 函数创建一个子进程，由子进程来处理该连接，父进程将会等待子进程处理完成。
![[Pasted image 20240115112414.png]]

每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，因而这种模型无法支撑C10K的服务器。

## 多线程模型
线程是轻量级的进程，所占据的系统资源和线程间上下文切换的包袱都会更少。

**多线程模型**和多进程模型原理相同，由于采用线程，所耗费的资源会更少，但仍需要为每个连接配置一个线程，这同样无法支撑C10K的服务器。

# I/O多路复用
既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 **I/O 多路复用**技术。

select/poll/epoll 是内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

## select/poll
select 实现多路复用的方式是：
1. 用户程序将已连接的 Socket 都放到一个**文件描述符集合**
2. 调用 select 函数将文件描述符集合**拷贝**到内核里，内核通过遍历集合的方式判断一个Socket是否可读或者可写，并打上标记。
3. 内核把整个文件描述符集合**拷贝**回用户态里
4. 用户态再次**遍历**集合找到可读或可写的 Socket，然后再对其处理。



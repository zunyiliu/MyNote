# 为什么要有 DMA 技术?
在没有DMA技术以前，从磁盘中读取数据到用户空间的过程如下，CPU需要全程参与IO过程，这是对资源的浪费。
![[Pasted image 20240110113716.png]]

有了DMA技术后，从磁盘中读取数据到用户空间的过程如下，CPU只参与了将内核空间中的数据拷贝到用户空间。
![[Pasted image 20240110113759.png]]

# 传统文件传输有多糟糕
以一个网络传输为例，我们需要用到两个系统调用，他们背后的过程如下图，整个过程经历了4次上下文切换（两个系统调用）、4次数据拷贝。
```cpp
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
```
![[Pasted image 20240110113854.png]]

为了优化文件传输的性能，我们需要**减少用户态与内核态的上下文切换次数**与**减少数据拷贝次数**。

# 如何实现零拷贝
零拷贝技术实现的方式通常有 2 种：
- mmap + write
- sendfile
下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。

## mmap+write
在前面我们知道，`read()` 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 `mmap()` 替换 `read()` 系统调用函数。

`mmap()` 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。
![[Pasted image 20240110114139.png]]
这样整个过程变为4次上下文切换、3次数据拷贝。

## sendfile
在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 `sendfile()`，函数形式如下：
```C
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

首先，它可以替代前面的 `read()` 和 `write()` 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。
其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：
![[Pasted image 20240110114257.png]]


进一步优化，如果网卡支持 SG-DMA 技术，可以通过将缓冲区描述符和数据长度传到 socket 缓冲区，这样就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里：
![[Pasted image 20240110114413.png]]

这就是所谓的**零拷贝（_Zero-copy_）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。**。


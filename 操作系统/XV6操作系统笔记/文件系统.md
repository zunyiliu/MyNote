# open全流程
![[Pasted image 20240117150100.png]]
open系统调用流程如上图，其系统调用接口如下：
```c
int open(const char*, int);
// 第一个参数是需要打开的文件路径
// 第二个参数是打开文件的权限
```

## sys_open
该函数流程如下：
1. 读取参数文件路径和文件权限。
2. 调用`begin_op()`函数，只要涉及文件系统的操作都要在log中记录
3. 如果权限中包含create，就需要调用`create()`先创建该文件，否则调用`namei()`找到该文件的inode
4. 调用`ilock()`函数获取文件inode的锁
5. 调用`filealloc()`函数获取一个空的file结构体，调用`fdalloc()`函数为该文件分配一个文件描述符
6. 设置文件file结构体的各项参数
7. 调用函数`iunlock()`释放inode的锁，调用`end_op()`结束log操作

## begin_op
log机制的相关函数，可以直接看另一篇[笔记](obsidian://open?vault=%E4%BB%8E%E5%A4%A7%E4%B8%89%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0&file=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FMIT-6.S081%E7%AC%94%E8%AE%B0%2FLec15%20Crash%20recovery)

## namei
该函数接口如下：
```c
struct inode* namei(char *path)
// 传入文件路径，返回该路径的文件的inode
```

该函数又会直接调用`namex()`函数

## nameiparent
该函数接口如下：
```c
struct inode* nameiparent(char *path, char *name)
// 传入文件路径，返回该路径的文件的父inode，并将路径的最后一个文件复制到name参数中
```

该函数又会直接调用`namex()`函数

## namex
该函数接口如下：
```c
static struct inode* namex(char *path, int nameiparent, char *name)
// 第一个参数是文件路径
// 第二个参数为0，就表示找到文件路径的最后一个文件，否则就找到父文件
// 第三个参数用于找父文件时，返回最后一个元素的名称
```

该函数流程如下：
1. 首先获取起始文件inode：
	- 如果文件路径从根目录开始，就直接获取根文件目录
	- 否则从`myproc()->cwd`获取当前文件目录
2. 每次从文件路径中取出头一个元素，并保留剩余的文件路径
3. 如果要寻找父文件，且剩余文件路径已经没了，就说明当前就停留在父文件inode上，可以直接返回
4. 否则调用`dirlookup()`，从当前inode中找到头元素对应的文件，并转移到该文件inode上
5. 直到最后，返回当前inode

## ilock
该函数负责获取inode的锁，同一时刻只允许一个进程使用一个inode

## create
该函数负责在指定的文件路径上创建一个指定类型的文件。

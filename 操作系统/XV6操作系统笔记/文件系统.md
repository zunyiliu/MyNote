# open全流程
![[Pasted image 20240117150100.png]]
open系统调用流程如上图，其系统调用接口如下：
```c
int open(const char*, int);
// 第一个参数是需要打开的文件路径
// 第二个参数是打开文件的权限
```

## sys_open
该函数流程如下：
1. 读取参数文件路径和文件权限。
2. 调用`begin_op()`函数，只要涉及文件系统的操作都要在log中记录
3. 如果权限中包含create，就需要调用`create()`先创建该文件，否则调用`namei()`找到该文件的inode
4. 调用`ilock()`函数获取文件inode的锁
5. 调用`filealloc()`函数获取一个空的file结构体，调用`fdalloc()`函数为该文件分配一个文件描述符
6. 设置文件file结构体的各项参数
7. 调用函数`iunlock()`释放inode的锁，调用`end_op()`结束log操作

## begin_op
log机制的相关函数，可以直接看另一篇[笔记](obsidian://open?vault=%E4%BB%8E%E5%A4%A7%E4%B8%89%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0&file=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FMIT-6.S081%E7%AC%94%E8%AE%B0%2FLec15%20Crash%20recovery)

## namei
该函数接口如下：
```c
struct inode* namei(char *path)
// 传入文件路径，返回该路径的文件的inode
```

该函数又会直接调用`namex()`函数

## nameiparent
该函数接口如下：
```c
struct inode* nameiparent(char *path, char *name)
// 传入文件路径，返回该路径的文件的父inode，并将路径的最后一个文件复制到name参数中
```

该函数又会直接调用`namex()`函数

## namex
该函数接口如下：
```c
static struct inode* namex(char *path, int nameiparent, char *name)
// 第一个参数是文件路径
// 第二个参数为0，就表示找到文件路径的最后一个文件，否则就找到父文件
// 第三个参数用于找父文件时，返回最后一个元素的名称
```

该函数流程如下：
1. 首先获取起始文件inode：
	- 如果文件路径从根目录开始，就直接获取根文件目录
	- 否则从`myproc()->cwd`获取当前文件目录
2. 每次从文件路径中取出头一个元素，并保留剩余的文件路径
3. 如果要寻找父文件，且剩余文件路径已经没了，就说明当前就停留在父文件inode上，可以直接返回
4. 否则调用`dirlookup()`，从当前inode中找到头元素对应的文件，并转移到该文件inode上
5. 直到最后，返回当前inode

## ilock
该函数负责获取inode的锁，同一时刻只允许一个进程使用一个inode

## create
该函数负责在指定的文件路径上创建一个指定类型的文件。

该函数流程如下：
1. 调用函数`nameiparent()`找到文件路径上的父文件inode
2. 调用`ilock()`获取该父文件inode的锁
3. 调用`iallock()`分配一个空的inode
4. 更新该inode的信息
5. 调用`dirlink()`将该文件放入父文件目录中

## dirlink
该函数接口如下：
```c
// Write a new directory entry (name, inum) into the directory dp.  
int dirlink(struct inode *dp, char *name, uint inum)
```
inode包含多种类型，其中就有文件目录，实际就是在inode指向的数据块中写入一条条的`dirent`，这样就在文件目录中保存了文件。

## filealloc
内核中维护打开的file的数量是有限的，因而需要用文件表ftable中找到一个空闲的file然后返回

## fdalloc
每个进程维护当前进程打开的文件的文件描述符，具体而言就是在一个指针数组中根据文件描述符找到对应的文件指针。

# close全流程
![[Pasted image 20240117194606.png]]
close流程图如上。

## sys_close
该函数流程如下：
1. 读取需要关闭的文件描述符
2. 将该进程中的文件描述符对应的文件置为0，表示不在维护
3. 调用`fileclose`，关闭对应的文件

## fileclose
file是内核维护的打开的文件，该函数流程如下：
1. 将该file的引用-1，如果引用变为0，就进入下一步
2. 将该file清空，然后调用`iput`释放该file对应inode的空间

## iput
该函数负责将inode的引用-1，如果当前inode的引用为0且没有硬链接，就直接回收该inode：
1. 调用`itrunc`，释放inode的所有空间，包括数据块空间
2. 调用`iupdate`，将inode的内容写入磁盘中

# read全流程
![[Pasted image 20240117160948.png]]
read的函数调用流程如上。

## sys_read
该函数流程如下：
1. 读取参数fd、addr、n，分别为需要读取的文件描述符、用户空间地址、读取大小
2. 根据fd，从进程维护的文件描述符数组中找到对应的文件file
3. 调用函数`fileread()`

## fileread
根据文件类型，`fileread`函数会跳转不同分支处理，对于文件读取，流程如下：
1. 调用`ilock()`，获取该文件对应的inode的锁
2. 调用`readi()`，从文件记录的上一次偏移处开始读取
3. 调用`iunlock()`，释放该文件对应的inode的锁

## bmap
该函数负责从inode中读取偏移处的数据块块号
```c
static uint bmap(struct inode *ip, uint bn)
// 第一个参数是需要读取的inode
// 第二个参数是需要读取的偏移下标
```

inode对应的数据块如下，前12个都是直接索引，最后一个是一级索引。
![[Pasted image 20240117182640.png]]

因而该函数流程如下：
1. 如果`bn`小于12，说明从直接索引处读取对应数据块号即可，如果该数据块还没有分配，就调用`balloc()`获取一个空的数据块，然后返回
2. 否则说明要从一级索引中读取，我们首先将`bn` - 12，然后在一级索引中找到对应的数据块号，然后返回

## bread
该函数负责从对应设备（磁盘）中读取对应块号的磁盘块，然后返回其在buffer中的缓存，具体可以直接看另一篇[笔记](obsidian://open?vault=%E4%BB%8E%E5%A4%A7%E4%B8%89%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0&file=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FMIT-6.S081%E7%AC%94%E8%AE%B0%2FLec14%20File%20systems)

## readi
该函数负责从对应的inode中读取数据，其接口如下：
```c
int readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)
// 第一个参数是需要读取的inode
// 第二个参数表示目的地址是否为用户空间地址
// 第三个参数表示当前开始读取的偏移量
// 第四个参数是需要读取的大小
```

函数流程如下：
1. 不断循环，直到读取完n个数据
2. 调用`bp = bread(ip->dev, bmap(ip, off/BSIZE));`，利用bmap找到off所在的块号，利用bread读取对应块号的buffer缓存
3. 从buffer缓存中读取数据

# write流程
![[Pasted image 20240117192658.png]]
write流程图如上。

## sys_write
和sys_read一样的流程，读取三个参数分别是文件描述符、用户空间地址、写入长度。然后调用`filewrite`

## filewrite
该函数流程如下：
1. 首先确定一次最后能写入的数据大小max
2. 循环直到写入了n个数据
3. 在`begin_op`、`end_op`之间和`ilock`、`iunlock`之间调用`writei`，完成写入

## writei
该函数流程如下：
1. 调用`bp = bread(ip->dev, bmap(ip, off/BSIZE));`，读取出需要写入的磁盘块的buffer缓存
2. 调用`either_copyin`写入到buffer缓存中
3. 调用`log_write`进行日志记录
4. 更新inode，然后调用`iupdate`，将inode块进行写入

# mkdir全流程
![[Pasted image 20240117201401.png]]
mkdir全流程如上图，实际上的流程如下：
1. 读取传入的路径
2. 调用`create`在对应路径处创建一个文件目录

# chdir全流程
chdir流程如下：
1. `sys_chdir`读取对应的文件路径
2. 调用`namei`，找到对应文件路径的文件inode
3. 判断该文件是否为目录，如果不是就终止
4. 将进程的当前目录设置成新的文件inode，并调用`iput`将之前的所在的文件inode释放

# link/unlink全流程
此处的link实际上就是硬链接，硬链接实际上就是对于同一个文件inode，有多个文件路径可以找到它，对应的文件inode的nlink就要+1。

sys_link流程如下：
1. 从参数中读取旧路径和新路径
2. 调用`namei`，找到旧路径对应的文件inode
3. 判断inode的类型，如果是目录就不行，因为硬链接不允许链接目录
4. `ip->nlink++;`
5. 调用`nameiparent`，找到新路径的父文件
6. 调用`dirlink`，在新路径父文件中添加该文件的目录项

sys_unlink的操作基本相同




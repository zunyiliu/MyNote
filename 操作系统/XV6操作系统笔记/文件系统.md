# open全流程
![[Pasted image 20240117150100.png]]
open系统调用流程如上图，其系统调用接口如下：
```c
int open(const char*, int);
// 第一个参数是需要打开的文件路径
// 第二个参数是打开文件的权限
```

## sys_open
该函数流程如下：
1. 读取参数文件路径和文件权限。
2. 调用`begin_op()`函数，只要涉及文件系统的操作都要在log中记录
3. 如果权限中包含create，就需要调用`create()`先创建该文件，否则调用`namei()`找到该文件的inode
4. 调用`ilock()`函数获取文件inode的锁
5. 调用`filealloc()`函数获取一个空的file结构体，调用`fdalloc()`函数为该文件分配一个文件描述符
6. 设置文件file结构体的各项参数
7. 调用函数`iunlock()`释放inode的锁，调用`end_op()`结束log操作

## begin_op
log机制的相关函数，可以直接看另一篇[笔记](obsidian://open?vault=%E4%BB%8E%E5%A4%A7%E4%B8%89%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0&file=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FMIT-6.S081%E7%AC%94%E8%AE%B0%2FLec15%20Crash%20recovery)

## namei
该函数接口如下：
```c
struct inode* namei(char *path)
// 传入文件路径，返回该路径的文件的inode
```

该函数又会直接调用`namex()`函数

## nameiparent
该函数接口如下：
```c
struct inode* nameiparent(char *path, char *name)
// 传入文件路径，返回该路径的文件的父inode，并将路径的最后一个文件复制到name参数中
```

该函数又会直接调用`namex()`函数

## namex
该函数接口如下：
```c
static struct inode* namex(char *path, int nameiparent, char *name)
// 第一个参数是文件路径
// 第二个参数为0，就表示找到文件路径的最后一个文件，否则就找到父文件
// 第三个参数用于找父文件时，返回最后一个元素的名称
```

该函数流程如下：
1. 首先获取起始文件inode：
	- 如果文件路径从根目录开始，就直接获取根文件目录
	- 否则从`myproc()->cwd`获取当前文件目录
2. 每次从文件路径中取出头一个元素，并保留剩余的文件路径
3. 如果要寻找父文件，且剩余文件路径已经没了，就说明当前就停留在父文件inode上，可以直接返回
4. 否则调用`dirlookup()`，从当前inode中找到头元素对应的文件，并转移到该文件inode上
5. 直到最后，返回当前inode

## ilock
该函数负责获取inode的锁，同一时刻只允许一个进程使用一个inode

## create
该函数负责在指定的文件路径上创建一个指定类型的文件。

该函数流程如下：
1. 调用函数`nameiparent()`找到文件路径上的父文件inode
2. 调用`ilock()`获取该父文件inode的锁
3. 调用`iallock()`分配一个空的inode
4. 更新该inode的信息
5. 调用`dirlink()`将该文件放入父文件目录中

## dirlink
该函数接口如下：
```c
// Write a new directory entry (name, inum) into the directory dp.  
int dirlink(struct inode *dp, char *name, uint inum)
```
inode包含多种类型，其中就有文件目录，实际就是在inode指向的数据块中写入一条条的`dirent`，这样就在文件目录中保存了文件。

## filealloc
内核中维护打开的file的数量是有限的，因而需要用文件表ftable中找到一个空闲的file然后返回

## fdalloc
每个进程维护当前进程打开的文件的文件描述符，具体而言就是在一个指针数组中根据文件描述符找到对应的文件指针。

# read全流程
![[Pasted image 20240117160948.png]]
read的函数调用流程如上。

## sys_read
该函数流程如下：
1. 读取参数fd、addr、n，分别为需要读取的文件描述符、用户空间地址、读取大小
2. 根据fd，从进程维护的文件描述符数组中找到对应的文件file
3. 调用函数`fileread()`

## fileread
根据文件类型，`fileread`函数会跳转不同分支处理，对于文件读取，流程如下：
1. 调用`ilock()`，获取该文件对应的inode的锁
2. 调用`readi()`，从文件记录的上一次偏移处开始读取
3. 调用`iunlock()`，释放该文件对应的inode的锁

## bmap
该函数负责从inode中读取偏移处的数据块块号
```c
static uint bmap(struct inode *ip, uint bn)
// 第一个参数是需要读取的inode
// 第二个参数是需要读取的偏移下标
```

inode对应的数据块如下，前12个都是直接索引，最后一个是一级索引。
![[Pasted image 20240117182640.png]]

因而该函数流程如下：
1. 如果`bn`小于12，说明从直接索引处读取对应数据块号即可，如果该数据块还没有分配，就调用`balloc()`获取一个空的数据块，然后返回
2. 否则说明要从一级索引中读取，我们首先将`bn` - 12，然后在一级索引中找到对应的数据块号，然后返回

## bread
该函数负责从对应设备（磁盘）中读取对应块号的磁盘块，然后返回其在buffer中的缓存，具体可以直接看另一篇[笔记](obsidian://open?vault=%E4%BB%8E%E5%A4%A7%E4%B8%89%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AD%A6%E4%B9%A0&file=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FMIT-6.S081%E7%AC%94%E8%AE%B0%2FLec14%20File%20systems)

## readi
该函数负责从对应的inode中读取数据，其接口如下：
```c
int readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)
// 第一个参数是需要读取的inode
// 第二个参数表示目的地址是否为用户空间地址
// 第三个参数表示当前开始读取的偏移量
// 第四个参数是需要读取的大小
```

函数流程如下：
1. 不断循环，直到读取完n个数据
2. 调用`bp = bread(ip->dev, bmap(ip, off/BSIZE));`，利用bmap找到off所在的块号，利用bread读取对应块号的buffer缓存
3. 从buffer缓存中读取数据

# write流程
![[Pasted image 20240117192658.png]]
write流程图如上。

## sys_write
和sys_read一样的流程，读取三个参数分别是文件描述符、用户空间地址、写入长度。然后调用`filewrite`

## filewrite
该函数流程如下：
1. 首先确定一次最后能写入的数据大小max
2. 循环直到写入了n个数据
3. 在`begin_op`、`end_op`之间和`ilock`、`iunlock`之间调用`writei`，完成写入

## writei

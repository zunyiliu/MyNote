# 概述
有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上：
- 系统调用：用户程序执行`ecall`指令要求内核为其做点什么
- 异常：（用户或内核）指令做了一些非法的事情
- 设备中断：一个设备，例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注

其中，我们还可以根据Trap发生位置分为：
- 从用户空间陷入；
- 从内核空间陷入；

按照`scause`寄存器原因可分为：
![[Pasted image 20230925174928.png]]

处理这些情况的机制被称为Trap。

# Trap中的RISC-V硬件
## RISC-V重要寄存器
- `pc`：程序计数器
- `satp`：指向当前页表的物理内存地址
- `stval`：存放发生`page fault`的虚拟地址
- `stvec`：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱
- `sepc`：当发生陷阱时，RISC-V会在这里保存程序计数器`pc`（因为`pc`会被`stvec`覆盖）。`sret`（从陷阱返回）指令会将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`的去向
- `scause`： RISC-V在这里放置一个描述陷阱原因的数字
- `sscratch`：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场
- `sstatus`：其中的**SIE**位控制设备中断是否启用。如果内核清空**SIE**，RISC-V将推迟设备中断，直到内核重新设置**SIE**。**SPP**位指示陷阱是来自用户模式还是管理模式，并控制`sret`返回的模式。

## Trap机制中的硬件操作
当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：
1. 如果陷阱是设备中断，并且状态**SIE**位被清空，则不执行以下任何操作。
2. 清除**SIE**以禁用设备中断。
3. 将`pc`复制到`sepc`。
4. 将当前模式（用户或管理）保存在状态的**SPP**位中。
5. 设置`scause`以反映产生陷阱的原因。
6. 将模式设置为管理模式。
7. 将`stvec`复制到`pc`，从而跳转到`stvec`地址处的指令
8. 在新的`pc`上开始执行。

**请注意**，CPU不会切换到内核页表，不会切换到内核栈，也不会保存除`pc`之外的任何寄存器。内核软件必须执行这些任务。RISC-V这样做是为了给内核软件提供足够的自由度。

# Trap机制：系统调用
## 概述
![[Pasted image 20231229165847.png]]
系统调用情况下的Trap机制如上图

## ecall
在用户空间中，`user.h`头文件中提供了所有系统调用的函数声明，用户程序可以直接调用这些函数，并通过**编译**，并在**链接**阶段找到对应的函数定义。

这些系统调用函数的生成方式在`usys.pl`文件中写明，这是一个脚本文件，用于生成所有系统调用函数在用户空间的入口。经过**编译**后生成对应的目标文件，其汇编形式如下：
![[Pasted image 20231229165417.png]]

每个系统调用函数在用户空间的入口都是将对应系统调用的**编号**写入`a7`寄存器中，随后调用`ecall`指令。告知内核进入Trap机制，同时**RISC-V硬件**会完成其工作。

## uservec
执行`ecall`指令后，**RISC-V硬件**将`stvec`复制到`pc`，从而跳转到`stvec`地址处的程序，这就是`kernel/trampoline.S`中的`uservec`函数。

该函数步骤如下：
1. 将该进程用户空间的所有寄存器存放在`proc->trapframe`中
2. 从`proc->trapframe`中读取`kernel_sp`，即内核栈指针
3. 从`proc->trapframe`中读取`kernel_hartid`，即进程运行的CPU ID
4. 从`proc->trapframe`中读取`kernel_trap`，即`usertrap`函数地址
5. 从`proc->trapframe`中读取`kernel_satp`，即内核页表的物理地址
6. 将内核页表物理地址写入`satp`寄存器中，无缝衔接到内核空间
7. 跳转到`usertrap`函数

>Q：为什么`stvec`存储了`uservec`函数的地址？
>A：答案在`usertrapret`函数中
>
>Q：将寄存器值存放到 `proc->trapframe` 时使用了 `sscratch` 寄存器，为什么该寄存器存着TRAPFRAME的虚拟地址？
>A：答案在`userret`函数中
>
>Q：为什么`proc->trapframe`中存储了kernel的相关信息？
>A：答案在`usertrapret`函数中
>
>Q：为什么能无缝衔接到内核空间，而不是因为页表出错而直接程序崩溃？
>A：所有进程的用户空间和内核空间的TRAMPOLINE的虚拟地址相同，因而从用户页表切换到内核页表不会影响TRAMPOLINE虚拟地址的翻译。
>
>Q：为什么切换内核空间后就不能再使用TRAPFRAME的虚拟地址
>A：因为内核空间中没有映射TRAPFRAME，因而相同的虚拟地址映射的不是TRAPFRAME

## usertrap
该函数负责对来自用户空间Trap的情况进行分类处理，本次我们只讨论系统调用的处理情况。

该函数步骤如下：
1. 将`kernelvec`函数地址写入`stvec`中，这样来自内核的中断或异常就会跳转到`kernelvec`函数处理
2. 从`sepc`寄存器中读取epc的值到`p->trapframe->epc`中，并加上`4`，表示返回地址是系统调用的下一条指令。这样做的目的是防止在执行系统调用时切换到了别的进程，这样`sepc`中的值就可能发生改变，因而保存到进程本身的结构中是最好的选择。
3. 打开设备中断：进入Trap机制时，RISC-V硬件关闭了设备中断，这里要重新开启，从而可以接收来自外部设备的中断
4. 调用`syscall`函数，从而能够执行相关系统调用
5. 调用`usertrapret`函数

## usertrapret
该函数负责准备返回用户空间的工作。

该函数步骤如下：
1. 关闭设备中断，回到用户空间后RISC-V硬件会根据`SPIE`标志位重新打开
2. 将`uservec`函数的地址写入`stvec`寄存器中
3. 将`satp`寄存器的值写入`p->trapframe->kernel_satp`
4. 将内核栈底的地址写入`p->trapframe->kernel_sp`
5. 将`usertrap`函数地址写入`p->trapframe->kernel_trap`
6. 将cpuid写入`p->trapframe->kernel_hartid`
7. 设置`status`寄存器中的`SPP`标志位和`SPIE`标志位，这样回到用户空间后就会将模式设置为用户模式，并重新打开中断
8. 将`p->trapframe->epc`写入`sepc`寄存器中，这样之后就能正确返回用户空间中的地址
9. 调用`userret`函数

## userret
该函数步骤如下：
1. 将用户页表物理地址加载到`satp`寄存器中，完成内核空间到用户空间的无缝衔接
2. 将存在`p->trapframe`中的寄存器加载出来，从而恢复进程的用户空间状态
3. 将TRAPFRAME的虚拟地址存在`sscratch`寄存器中
4. `sret`回到`sepc`寄存器中的地址，也就是用户空间中的地址

## 为什么进入Trap机制时，什么都准备好了
这里我们解答问什么在进入Trap机制时，`stvec`存储了`uservec`函数的地址、`sscratch`寄存器存储着TRAPFRAME的虚拟地址、`proc->trapframe`中存储了kernel的寄存器信息。

我们执行用户程序前肯定是分配了一个进程，`allocproc`函数中设置了`p->context.ra = (uint64)forkret`，因而当scheduler切换到该进程时，就会回到`forkret`函数，而该函数又调用了`usertrapret`函数，按照上述步骤，所有进入Trap所需的信息就都准备好了。

# Trap机制：内核陷入
## 概述
![[Pasted image 20231230162208.png]]
内核陷入的流程如上。所谓内核陷入，就是指内核状态下发生了设备中断或异常，继而进入内核中的Trap机制。

## kernelvec
从用户空间进入内核后，在usertrap函数会设置`stvec`寄存器的值为`kernelvec`函数的地址，因而在内核中发生中断或异常后，就会跳转到`kernelvec`函数执行。

该函数步骤如下：
1. 通过将`sp`指针向下移动，在内核栈中腾出空间
2. 将所有寄存器保存到内核栈中，从而保存现场
3. 调用`kerneltrap`h函数
4. 函数返回后从内核栈中重新加载所有寄存器，恢复现场，并进行返回（返回到`sepc`寄存器z中的地址）

## kerneltrap
- `kerneltrap`为两种类型的陷阱做好了准备：设备中断和异常。
- 它调用`devintr`(_kernel/trap.c_:177)来检查和处理前者，如果是或者则会返回0
- 如果陷阱不是设备中断，则必定是一个异常，内核中的异常将是一个致命的错误；内核调用`panic`并停止执行。
- 如果`devintr`返回了2，表示是一个计时器中断，需要调用`yield`函数让出CPU

# Trap机制：异常
原始XV6对来自用户空间和内核空间的异常都是冷处理：
- 如果来自用户空间，就杀死进程，并打印出错信息。
- 如果来自内核空间，就直接内核崩溃。

现代操作系统应该要对异常进行处理，同时我们也可以通过异常处理实现一些有用的功能。就`page fault`而言，我们可以实现以下虚拟内存管理的功能：
- lazy allocation
- copy-on-write fork
- demand paging
- memory mapped files

其中我们对*lazy allocation*和*copy-on-write fork*进行了实验，具体可以看实验笔记。

# Trap机制：中断处理
## 概述
本文我们以XV6中UART0的设备中断进行讲解，其函数调用图如下：
![[Pasted image 20240103194229.png]]
如果在用户空间发生设备中断，那么就会和系统调用的路径一样，进入到`usertrap`函数，在查看Trap原因发现不是系统调用后，就会调用`devintr`函数，其中就有设备中断的处理。

如果在内核空间发生设备中断，那么就会根据Trap机制：内核陷入的流程，来到`kerneltrap`函数，同样会调用`devintr`函数来处理设备中断。

## devintr
该函数负责检查设备中断的原因，进而根据选择对应的设备中断处理函数。对于UART0设备的中断，此处会调用`uartintr`函数。

## uartintr
该函数首先读取键盘输入的字符，该字符暂时储存在设备的寄存器中，我们需要将其读取到内核的读入缓冲区中。

该函数步骤如下：
1. 调用`uartgetc`函数，从对应寄存器中读取待输入的字符
2. 调用`consoleintr`函数，对该输入的字符进行处理
3. 循环直到设备中没有需要输入的字符
4. 接着调用`uartstart`函数，继续处理输出缓冲区中等待输出的字符，具体可见[[设备read与write的全流程#write流程]]

## consoleintr
该函数根据读入字符的不同进行不同的处理，这里我们只讨论正常字符的处理。

正常字符的处理步骤如下：
1. 调用`consputc`函数，将该键盘输入的字符进行输出，这样就能显示在显示屏上。
2. 将该字符放入输入缓冲区中，输入缓冲区同样是一个环形缓冲区，维护两个索引，并在以下情况触发缓冲区清空，进而唤醒等待读取输入的进程。
	- 输入了`\n`字符
	- 输入缓冲区已满

**这也就解释了为什么键盘输入后，不仅能在显示屏上看到输入的字符，还能被程序所读取。**

## consputc
该函数直接调用`uartputc_sync`函数。

## uartputc_sync
该函数适用于内核状态下直接输出的情况，需要循环直到设备空闲，然后将字符送入设备寄存器中，完成输出。


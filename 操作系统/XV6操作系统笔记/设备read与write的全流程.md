# 概述
XV6中有一个名为UART0的设备，负责管理键盘的输入以及显示屏的输出，根据内核虚拟地址空间与`kvminit()`函数，我们可以查看到该设备映射的虚拟地址为`0x10000000`。设备对应的各类寄存器也被映射到地址空间中，因而我们可以通过向地址写入或读出的方式来控制设备。

本文不深究设备各类寄存器的作用，也不涉及设备的各项初始化，实在是过于繁杂。本文聚焦于内核如何通过驱动程序与设备中断来实现**读取键盘输入**与**显示屏输出**。

# write流程
## 概述
![[Pasted image 20240103185327.png]]
write系统调用可以向指定的文件描述符进行写入，根据unix的设计思想“一切皆文件”，在XV6中设备也可以作为一个文件描述符，我们就可以通过打开设备得到其文件描述符，并通过write系统调用向设备进行写入，进而能在显示屏上显示我们想要的文字。

本文我们通过`sh`程序如何在显示屏上输出`$ `来进行讲解。

## 设备在用户空间的创建
`init.c`程序是我们在用户空间运行的第一个用户程序，根据代码显示如下，该程序通过`mknod`系统调用创建了`console`的设备，也就是我们的虚拟终端。
![[Pasted image 20240103185729.png]]

接着在`sh.c`程序中，我们通过以下代码，将console设备打开三次，这样就创建了0、1、2三个文件描述符，且都指向`console`这个设备。
![[Pasted image 20240103190001.png]]

## sys_write
用户程序所使用了类printf函数，实际上的内核都是对`write`系统调用的使用，也就是内核空间中的sys_write，其函数接口如下：
```cpp
int write(int, const void*, int);
// 第一个参数为文件描述符
// 第二个参数为需要写入的内容的用户空间虚拟地址
// 第三个参数为写入内容的大小
```

该函数在内核空间中读取三个参数，并将文件描述符通过`argfd`函数转化为具体的文件，然后调用`filewrite`函数：
![[Pasted image 20240103190703.png]]

## filewrite
该函数接口如下：
```cpp
int filewrite(struct file *f, uint64 addr, int n)
// 第一个参数是需要写入的文件
// 第二个参数是需要写入的内容的地址
// 第三个参数是需要写入的内容的大小
```

该函数根据文件`f`的类型，选择不同的函数进行处理，在此场景中，由于`console`是一个设备，因而我们会进入以下分支：
![[Pasted image 20240103190953.png]]

这里涉及到`devsw`数组，该数组对`console`设备的初始化如下：
![[Pasted image 20240103191052.png]]

因而我们接下来就会调用`consolewrite`函数。

## consolewrite
该函数接口如下：
```cpp
int consolewrite(int user_src, uint64 src, int n)
// 第一个参数表示src是否来自用户空间
// 第二个参数表示需要写入的内容的地址
// 第三个参数表示需要写入的内容的大小
```

函数步骤如下：
1. 获取输入缓冲区的锁
2. 遍历大小n，每次调用`either_copyin`函数从`src`地址读取一个字符
3. 调用`uartputc`函数，将字符放入输出缓冲区
4. 释放输入缓冲区的锁，并返回实际输出的字符

## uartputc
该函数接收一个字符，并将该字符放入输出缓冲区。输出缓冲区是一个环形缓冲区，维护**两个索引**分别表示下一个要写入的位置和物理设备下一个要读取的位置。

该函数步骤如下：
1. 获取输出缓冲区的锁
2. 如果输出缓冲区已满，就进入sleep，直到被唤醒
3. 如果输出缓冲区未满，将字符放入缓冲区，并更新索引
4. 调用`uartstart`函数，从输出缓冲区读取字符，并送入设备寄存器中，告知设备进行输出。
5. 释放输出缓冲区的锁

## uartstart
该函数负责从输出缓冲区中读取字符，将其送入设备相应的寄存器中，从而告知设备输出该字符。设备将会与CPU并行运行，在发现寄存器被修改后进行运行，并在完成工作后发起中断，从而进行Trap机制：中断处理。

该函数步骤如下：
1. 判断输出缓冲区是否为空，如果为空直接返回
2. 通过设备寄存器判断设备是否*正忙*，如果正忙就不能进行写入，直接返回
3. 从输出缓冲区读取一个字符，并更新索引
4. 将该字符写入设备对应的寄存器，实际就是在该寄存器映射的内核地址进行修改
5. 唤醒`uartputc`上sleep的进程

## 小结
这样我们就完成了一个字符的写入，在设备完成写入后，设备就会发起一个中断，CPU就会进入[[Trap机制#Trap机制：中断处理]]

# read流程
## 概述
![[Pasted image 20240103200119.png]]
read系统调用可以从指定的文件描述符中进行读取操作，这当然也包括设备（也就是键盘）

## sys_read
`sh.c`程序采用`gets`函数读取键盘的输入，而该函数又调用了`read`系统调用，其接口如下：
```cpp
int read(int, void*, int);
// 第一个参数是需要读取的文件描述符
// 第二个参数是读取内容需要存储的地址
// 第三个参数是读取内容的最大长度
```

该函数在内核空间中读取对应参数后，调用`fileread`函数。

## fileread
该函数根据文件的不同类型调用不同的函数，这里由于是对设备进行读取，因而会进入以下分支：
![[Pasted image 20240103200649.png]]

与`filewrite`相同，这里会跳转到`consoleread`函数。

## consoleread
该函数步骤如下：
1. 获取输入缓冲区的锁
2. 判断输入缓冲区是否为空，如果为空就进入sleep
3. 从输入缓冲区中读取字符，并修改索引
4. 将该字符通过`either_copyout`函数拷贝到对应的用户空间虚拟地址
5. 遇到换行符或超出最大长度时，return

## 小结
这样我们就可以在键盘完成输入，Trap机制：中断处理流程将输入字符放入输入缓冲区后，从输入缓冲区中读取字符串并进行返回，这样`sh.c`程序就能读取对应的指令。